<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[适用于实验室的新型能量回收污水处理铜板蚀刻机设计]]></title>
    <url>%2F2019%2F02%2F11%2FJienengJianPaiTogether%2F</url>
    <content type="text"><![CDATA[2017年神雾杯全国大学生节能减排大赛三等奖作品 适用于实验室的新型能量回收污水处理铜板蚀刻机设计设计者：范裕莹 董慧鑫 李纳瑞 陆婧 李亮 彭岩 罗豪指导教师：阳晓宇武汉理工大学 信息工程学院 武汉 430070 演示视频 作品内容简介本新型铜板蚀刻机对现有小型蚀刻机做出了改进，可将腐蚀后的污水进行处理，并将腐蚀反应产生的化学能加以收集。本蚀刻机共由三个子系统构成：污水处理子系统采用碱沉淀结合三维石墨烯吸附或阳离子交换树脂吸附的二级废液处理方法对高浓度的铜离子废液进行处理，使其达到排放标准，减少对环境的污染；能量回收子系统利用能量采集模块收集铜腐蚀原电池反应产生的电能并存储；控制子系统采用嵌入式技术，利用收集的能量控制腐蚀反应、废液处理和溶液流向。最终形成一条无污染，低耗能的PCB铜板蚀刻之路。 研制背景及意义近年来，随着印制线路板(Printed circuit board，PCB)行业迅速发展，据中国印制电路行业协会(CPCA)统计数据，2010年PCB产量达1.81亿立方米，占全球PCB产量的40%，居世界第一位。但随着PCB行业的迅速发展，其所带来的环境问题也日益突出。据统计[1]，2010年PCB行业的耗水量达6.15亿立方米；产生的蚀刻废液达109万立方米，每立方米约含铜145千克；PCB行业废水处理过程中产生的含铜污泥达60.74万吨。尤其是我国在PCB制造方面以代工为主，生产线从低端制造业起步，逐步向高端产品发展的特点，更导致其所带来的环境问题具有累积性，严重性和突发性[2]。与我国工业行业节能、增产不增污等政策指令的实施以及HJ-450-2008《清洁生产标准 印制电路板制造业》的颁布相比较，各大高校实验室，科研院所的小批量分散化电路板制作在PCB前端开发过程中产生了各种污染问题。经过本项目组研究发现，目前市场上的小型铜板蚀刻机结构简单，存在以下缺点：(1)适用于实验室的小型蚀刻机难以像大型蚀刻工厂一般将污水集中送厂处理，大部分污水被直接排入下水道，产生严重的污染问题；(2)为追求较高腐蚀速率，采用高耗能电器件，且其在腐蚀过程使溶液始终保持在较高温度范围内(20℃～55℃)，使溶液加速挥发，造成化学原料严重浪费；(3)缺乏相应的智能控制，加料排料完全依靠个人主观意识，且大部分电路工作者缺乏相应化学化工知识，在造成原料严重浪费的同时，伴随着较大危险性；基于以上背景，本项目组设计了这款适用于实验室的新型铜板蚀刻机。就分散实验室而言，此蚀刻机可以最大程度的改善现状，减少污染；就个人工作者而言，可以避免酸性蚀刻液对其身体造成伤害。此外，在节约电能、原料方面，此产品具有良好效果，满足了社会对节能减排的需求，响应了国家对绿色环保的号召。 方案设计目前实验室制造电路常用酸和双氧水来蚀刻铜板，电路制作后的蚀刻废液中含铜离子浓度非常高，针对以上背景分析，我们组提出了以下几个问题： 1）如何将产生的含铜废水就地处理？ 2）如何减少因操作者缺乏相关知识造成的危害与浪费？ 3）如何降低整个系统的能耗？ 通过小组实验研究发现，在蚀刻机中集成污水处理模块对实验室分散型污水就地处理，可简化污水处理流程，从而解决污染问题。我们采用碱沉淀的方法结合三维石墨烯或阳离子树脂的方式对污水进行处理，这种方法能耗低，无有毒副气体产生；采用特定的反应结构使反应更可控，结合嵌入式微处理器实现全自动化腐蚀过程，溶量用量精确控制，并减少人为操作，避免隐患发生；在蚀刻机中加入能量回收子系统并去除高能耗器件，可以收集被忽略的能量并减少系统能耗；能量回收子系统将该反应构成原电池，一方面隔离反应的主要原料，减少副反应降低危险性，另一方面可以从该反应之中获得电能用于反哺控制系统。本系统原理图如图1所示： 图1 系统原理图 本新型蚀刻机由控制子系统、污水处理子系统和能量回收子系统三部分构成。系统结构如图2所示，系统演示模型如图3所示： 图2 系统结构 图3 系统演示模型 2.1 控制子系统设计为实现全自动化控制，本蚀刻机采用超低功耗单片机MSP430作为主控芯片，结合液位传感器、pH传感器、矩阵键盘、OLED显示屏、球阀、气阀等外设构建控制系统，系统框图如图4所示。通过与液位传感器、pH传感器通信实时监测腐蚀反应进程，相应改变气阀状态，间断性添加腐蚀原材料，控制反应持续温和进行。此外，单片机通过控制相关球阀的开启，以控制腐蚀废液的流向，使废液流至污水处理模块，可达到排放标准。系统工作流程如图5所示： 图4 系统框图 图5 工作流程图 2.2 污水处理子系统设计本污水处理子系统是由碱沉淀、三维石墨烯吸附或阳离子交换树脂过滤构成的二级污水处理模块。其污水处理流程如图6所示。图中对于初步产生的含铜废液，先排入沉淀反应池中，经微处理器计算后向沉淀反应室内注入除杂剂(碱液)，调节其pH使该浓度下铜离子沉淀完全。沉淀反应进行一段时间，经滤纸过滤预处理后，废液流入阳离子交换树脂管道或三维石墨烯进行吸附处理，使最终结果满足《中华人民共和国污水综合排放标准》(GB8978-2015)一级标准。该废液即可直接排放，也可二次回收用于稀释参与反应的盐酸。滤除的沉淀经过初步处理后可以作为生产杀菌剂或催化剂的原材料。 图6 酸性蚀刻废液工艺流程图 2.3 能量回收子系统设计本能量采集系统以TI公司的低功耗电源管理芯片BQ25504为核心搭建而成，电路工作原理如图7所示。BQ25504内部集成低压升压电路，能够将外部微弱电压升压至锂离子电池的充电电压。通过外部配置电阻，确定充电电池欠压和过压电平，将收集到的能量有效的充至预先设定好的充电电压的锂离子电池内，并防止电池长时间放电导致电池损伤。该系统收集的能量可以用于整个系统的供电。其实物如下图8所示： 图7 电路工作原理框图 图8 电路实物图 2.4 节能装置设计本产品主要面向分散的电路设计者的电路设计需求，时间成本与经济收益不完全正相关，故我们通过减少加热等高能耗部件适度控制反应速率来优化蚀刻过程。同时我们采用原电池反应结构，隔绝反应原料，回收能量。原电池反应模块由反应槽、Nafion 117质子交换膜组成，如图9所示。其中铜板和碳板由特殊的夹具固定，如图10所示，该夹具与铜板和碳板两边的接触面导电性好。反应槽采用质子交换膜分隔出左右腔室，左腔室放置H2O2，NaCl溶液和碳板电极作正极，右腔室放置HCl、NaCl溶液和铜板作为负极，质子交换膜在反应过程中只允许氢离子流过，电子通过外部导线构成闭合回路。其优化点如下：1、减少氯气产生；2、降低原料损耗；3、降低反应的危险性。除此本产品利用低功耗气动阀门配合密闭容器构成可以向下级添加原料的防挥发储料室，如下图11所示： 图9 腐蚀反应装置图 图10 电极夹具模型剖视图 图11 储料室结构图气阀主要用于调控腔内气压，与酸性或氧化性溶液非直接接触，减小了所存储溶液对阀门材料的要求。当气阀关闭，内部大气与外部大气隔绝，液面稍微下降后内外气压差平衡使得液面不再下降；当气阀开启时，内外压强平衡，液体随重力流下，实现加料功能。由于该储料室在气阀关闭时为密闭空间，所以能够降低原料挥发。该储料室结构具有低功耗，防腐，防挥发的优点。 3. 工作原理与理论分析计算3.1 污水处理原理及理论分析实验室常用的铜板腐蚀反应利用的是铜失电子的氧化还原反应，该反应如式3.1-1所示： $Cu+2HCl+H_{2}O_{2}=CuCl_{2}+2H_{2}O$ （3.1-1）蚀刻后废液中含有高浓度的铜离子，通过多次测试废液中铜离子的平均浓度约为2370mg/L(见附录一)。一级废液处理原理：根据氢氧化铜的溶度积常数Ksp(氢氧化铜)=2.2×10-20,计算得碱沉淀所需的氢氧化钠量为3g，因为废液中存在少量未消耗的盐酸溶液，故碱量会增加至4g，可通过酸碱传感器，进一步量化加入的碱量。二级废液处理原理：针对实验室，可采用以下两种处理方法：1)三维石墨烯吸附。三维石墨烯是农业废弃物稻壳和Hummers法合成的氧化石墨烯的复合物。稻壳经碳化后富含微孔和中孔结构，比表面积达886.3m2/g，微孔含量约40%，中孔含量约60%；氧化石墨烯作为一种新型材料，具有二维单原子层结构、丰富的表面活性基团以及巨大的比表面积。但碳化后的稻壳粉易溶解在溶液中，且氧化石墨烯亲水性高，存在固液分离困难的问题，故通过二维石墨烯与稻壳活性炭的复合改性，大大提高两者的吸附能力，以及与溶液的分离。2)阳离子交换树脂吸附。阳离子交换树脂离解后，本体所含的负电基团，能吸附结合溶液中的其他阳离子，达到吸附的效果。不足之处是吸附速率慢，不可重复使用，但吸附效果极好，成本低。 3.2能量回收系统工作原理及理论分析由NERNST理论电动势计算公式[3]得： $EMF=1.4322V$通过化学状态改变可以求得理想状态下每摩尔铜失去2mol电子成为铜离子可产生53511.1mAxH的电量（详见附录二）。本系统装置中，由于氧化剂与还原剂被隔离，蚀刻反应发生后，在极板电动势作用下氢离子透过质子交换膜，结合过氧化氢形成水分子；同时电子在电场作用下定向移动，产生电流，构成闭合回路，如图12所示。该原电池可作为能量采集电路的输入，将其等效为戴维南电路，如图13所示。根据溶液电导公式[4,5]（其中C为电解质溶液浓度，A∞m为溶液的极限电导率，A为该类型电解质溶液的经验常数）： (3.2-1)发现增大电极极板的相对正对面积（AS）、减少极板间距（L）并加入强电解质(NaCl)可降低内阻，提高其电流输出能力。根据测试数据绘制三者联系图，如图14所示，随着板间间距不断减小，NaCl浓度不断增加，电路输入内阻不断减小。为提高电路采集效率，需尽可能减小输入内阻，故综合考虑实际工艺水平及成本效益并进行相关的测试分析后（详见附录一），板间间距选择2mm，电解质NaCl浓度选择9g/100mL。 图12 离子流向图 图13 戴维南等效电路图 图14 电阻与极板间距溶液浓度关系 4. 产品测试及性能分析为充分了解本蚀刻机在实际的腐蚀过程中，其性能参数的变化情况、电能的收集效果、废液处理效果，我们设计了相应的实验对本产品进行测试。 4.1 PCB板腐蚀效果分析本产品的PCB腐蚀效果从蚀刻均匀性、最小线宽、最小线距等方面进行分析。由上图可知，根据R=ρL/S（低频条件下）和测量出的电阻值计算铜板剩余厚度，计算出的蚀刻均匀度≥92%（详见附录一），故其蚀刻均匀度满足绝大多数电源电路乃至射频电路需求。图15为均匀性检测图。最小线宽蚀刻能力：如图16所示，当线宽为5mil、6mil、7mil、8mil、9mil、10mil时，蚀刻线两端导通，具有较好的腐蚀效果，故腐蚀最小蚀刻线宽≤5mil。最小线距：如图17所示，当相邻两根蚀刻线的线距分别为5mil、6mil、7mil、8mil、9mil、10mil时，线与线之间均不导通，故最小蚀刻间距≤5mil。综上所述，本蚀刻机蚀刻效果满足绝大部分电路设计要求。 图15均匀性检测图 图16 腐蚀的最小线宽实物图 图17腐蚀的最小线距图 4.2 污水处理效果分析本蚀刻机的污水处理模块将产生的污水第一次检测于2017年3月27日送至武汉理工大学材料研究与测试中心进行测试，如图18所示为主要测试结果（具体测试数据见附件一）。第二次检测于2017年5月10日送至武汉华正环境检测技术有限公司进行测试（检测报告见附录三），主要测试数据如表1所示。 图18 污水处理检测结果 (图18-a为第一级污水处理检测结果；图18-b为第二级污水处理（阳离子交换树脂吸附）检测结果；图18-c、d为第二级污水处理（三维石墨烯吸附）检测结果。)如上图18可得，经过碱沉淀之后，再通过阳离子交换树脂吸附或三维石墨烯吸附处理后的废液达到国家排放标准（一级排放标准为小于0.5mg/L），平均铜离子浓度从2370mg/L分别降至0.4552mg/L和0.3450mg/L（2370mg/L为腐蚀一块10cm*15cm厚1oz的单面覆铜板所得浓度）。以阳离子交换树脂为例，铜离子浓度可降低约： $ (2370-0.4552)÷2370=99.98% $ （4.2-1）且处理后的水可在本系统循环利用，滤渣经过初步处理可作为生产杀菌剂或催化剂的原材料。第二次送检检测了蚀刻废水中的几种主要的污染物，检测结果如表1： 表1 蚀刻废水主要污染物检测结果 检测项目 废水原液（mg/L） 树脂处理后（mg/L） 三维石墨烯处理后（mg/L） 铜 2.06×104 0.224 0.593 铅 12.8 ND ND 铬 0.231 0.017 0.005 标准覆铜板有相关的生产工艺和行业生产标准，但仍然存在一定的有毒重金属如铅等通过该检测数据可以看出，本系统对于几种常见的重金属污染污染物都有明显的降低功能，其中处理之后的铅浓度低于该测试仪器的化学检出限ND(0.1mg/L) ,铬的初始浓度满足一级水指标，但处理之后仍然有明显降低，且三维石墨烯的处理效果极佳。 4.3 节能效果分析利用微型电能测试器对系统耗电进行测试（具体测试结果与数据见附录一），表2为本蚀刻机稳定工作时单个蚀刻槽的各种能量及其效率： 表2 能量收集系统 腐蚀时间(s) 平均充电功率(mW) 充电电路效率 总化学能（J） 总收集能量(J) 340 19.08 55.70% 300.81 6.48 323 19.25 55.28% 292.28 6.19 354 17.91 59.70% 315.75 6.34 344 17.90 53.52% 286.85 6.16 362 17.77 58.69% 322.88 6.44 通过该表可以看出本蚀刻机，当腐蚀单块单面覆铜板(15cm×10cm)时，对电池的平均充电功率为18.38mW，平均腐蚀时间为6分钟，电路能量转换效率约为55%，能够在该反应中回收能量，目前测得该腐蚀反应产生平均电流约为20mA，但在实际测试中发现最大电流可达100mA（见附录一），能量回收方面也有巨大潜力。腐蚀一块该规格铜板收集的电能： $ E=P×t=360s×18.38mW=6.62×103mJ$ （4.3-1） 在增加能量回收系统的情况下，对该系统进行对比测试，结果如表3所示： 表3 能量对比表 表4 腐蚀方式对比表 消耗能量 回收能量 腐蚀方式 耗时 平均耗能 无能量回收 93mW*H 0 无设备腐蚀 30~90s 0 有能量回收 93mW*H 2mW*H AEM3500 30~120s 20.8W*H 本产品 300~360s 0.093W*H 本系统采用了创新性的结构，使得系统总能耗低，平均功率约930mW,最大瞬时功率约1.6W。但由于同时也取缔了常用腐蚀机的高能耗器件(平均功率约1kW)，蚀刻时间长于常用腐蚀方式，对比数据如表4所示。鉴于实验室使用时，对生产速度要求不高，本产品仍然具有很大的竞争力。 5. 效益分析据中商产业研究院大数据库数据知湖北省共有正规高职高校共128所，其中开设有电类专业院校共103所，占比约80.5%。每所高校拥有相关实验室数量为5~10个不等，以每所院校5个该实验室为例。高校实验室又是PCB板前端开发的主力军，在电路设计前期，电路设计需要不断改动，单个实验室周平均蚀刻铜板面积约为1m2。 5.1 减排效益分析1m2的标准覆铜板有铜305g，一般约60%的铜参与反应，即腐蚀掉183g的铜。蚀刻废液的铜离子平均浓度为2370mg/L，单个实验室每周可减少含铜废水约77.2L。若湖北高校40%的实验室采用了本新型腐蚀机，则每年（52周）可减少高浓度含铜污水排放： $77.2×52×309×5×0.4=2.48×105L $ （5.1-1） 根据《中华人民共和国污水排放标准》（GB 8978-2015）的规定，三级污水排放标准中含铜离子应小于2mg/L, 认定含铜离子≥2mg/L为被污染水源，据质量守恒原理与扩散原理[6]可知，在足够时间下，减少了因直接排放而污染的水： $2370mg/L×2.48×105L÷2mg/L=2.938×108L $ (5.1-2) 5.2 经济效益分析（1）电路板蚀刻后，直接排放的废液含高浓度铜离子，这些铜具有很高的回收价值。蚀刻机腐蚀一块规格为15cm×10cm（0.015m2）厚1oz的单面铜板（约有4.575g铜）可回收约1.78g铜。1.78g的铜产生约2.21g氧化铜，产生的氧化铜具有极好的杀菌与催化作用，且纯度较高。由于产生1g氧化铜需1g的氢氧化钠，根据氧化铜（0.69RMB/g）和氢氧化钠（0.098 RMB/g）的市场价值可知，回收1g氧化铜的净收入为0.592RMB。折合成1m2通过该统计数据可以得知，高校小型实验室每年在利用覆铜制作电路的同时每年产出氧化铜滤渣的净价值为： $(1÷0.015)×2.21×0.592×309×5×0.4×52=28.02$ 万元 （5.2-1） （2）市场优势。 表5装置成本核算 亚克力 木材 质子膜 阀门 电路 树脂 管道 其余零件 单价 130 200 500 70 100 5 2 / 数量 10 1 1 2 1 1 5 / 总价 1300 200 500 140 100 1 10 200 现有功能齐全蚀刻机销售大多超过4000元，本产品演示模型制作成本约2455元，仅约为现有蚀刻机售价的61%，量产成本可进一步降低，在价格上具有一定的市场优势。 6. 创新点及应用前景6.1 创新点（1）利用化学沉淀法结合阳离子交换树脂或三维石墨烯构成除污系统，可实现对蚀刻废液的就地处理，直接排放。（2）增加能量收集模块将腐蚀反应中产生的化学能转为电能并收集。（3）针对存储反应等设计了新型结构，达到节能、防腐、防挥发目的，使用方便，安全性高。 6.2 应用前景近年来工业上相继颁布增产不增污等政策指令及《清洁生产标准 印制电路板制造业》相关文献，这表明环境问题逐步进入人们的视野。电路板经蚀刻后，产生污染废液若处理不当会造成严重污染，且蚀刻液中铜具有很高的回收价值。本蚀刻机可以就地处理高浓度的含铜废液使其能达到我国《污水综合排放标准》(GB8978-1996)的一级标准。借助本产品可将废液中的铜回收利用作为生产杀菌剂或催化剂的原材料，变废为宝。此外，本产品可弥补市场空缺的同时，与以前产品相比，功耗降低至930mW，可实现全自动控制，操作简单。且本产品的成本仅约为目前蚀刻机售价的61%。综上所述，本产品具有较好的应用前景。 参考文献[1] 中国印制电路行业协会.中国印制电路行业协会工作专辑[R].上海：中国印制电路行业协会，2010. [2]秦琦，宋乾武，吴兆晴等.PCB行业环境治理之技术需求[J].环境工程技术学报，2012，02(5):456-460.DOI:10.3969/j.issn.1674-991X.2012.05.071. [3] 张文华.标准电极电势的间接计算［J］.高等函授学报，华中师范大学出版社.1999，01：35-36 [4] 刘成伦，徐龙君，鲜学福. 水溶液中盐的浓度与其电导率的关系研究[J]. 中国环境监测，1999，(04):21300-24. [5] 姚进一，许雅，归丽丽等.电导率与溶液浓度函数之间直线关系的经验公式研究[J].中国科技博览，2008，(20):5-6. [6] 孙硕,晋榕榕.城市表层土壤重金属污染物的扩散分析[J].时代金融(下旬),2012,(3):307-308.]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[牛客网]差值对数]]></title>
    <url>%2F2018%2F11%2F08%2F%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%B7%AE%E5%80%BC%E5%AF%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[小Q今天在上厕所时想到了这个问题：有n个数，两两组成二元组，相差最小的有多少对呢？相差最大呢？ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;limits.h&gt;using namespace std;class Solution &#123;public: void fun(vector&lt;int&gt; v) &#123; sort(v.begin(), v.end()); int min = INT_MAX; for (int i = 1; i &lt; v.size(); i++) &#123; if (v[i] - v[i - 1] &lt; min) min = v[i] - v[i - 1]; &#125; int count1 = 0; if (min == 0) &#123; for (int i = 0; i &lt; v.size(); i++) &#123; int j = i + 1; while (j &lt; v.size() &amp;&amp; v[i] == v[j]) &#123; count1++; j++; &#125; &#125; &#125; else &#123; for (int i = 1; i &lt; v.size(); i++) &#123; if (v[i] - v[i - 1] == min) count1++; &#125; &#125; /*cout &lt;&lt; count1 &lt;&lt; endl;*/ int count2 = 0; int max1 = v[v.size() - 1]; int min1 = v[0]; int maxnum = 0, minnum = 0; for (int i = 0; i &lt; v.size(); i++) &#123; if (v[i] == max1) maxnum++; if (v[i] == min1) minnum++; &#125; if (max1 == min1) count2 = v.size()*(v.size() - 1) / 2; else count2 = maxnum * minnum; cout &lt;&lt;count1&lt;&lt;" "&lt;&lt; count2 &lt;&lt; endl; &#125;&#125;;int main()&#123; int n; int temp; while (cin &gt;&gt; n) &#123; vector&lt;int&gt;v; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; v.push_back(temp); &#125; Solution s; s.fun(v); &#125;&#125; 算法首先进行排序首先看差值最小的对数：1.首先计算出最小差值是多少2,根据这个差值来判断2.1 如果差值为0，则是有相同的数，（比如3，3，3则有3对）不能单纯的计算相同数的个数，因为可能存在（3，3，2，2）这种情况，所以必须要遍历字符串，用1int j来寻找每个数相同个数的对数。 2.2 如果差值不为0，则直接计算有多少对差值为最小值的对数。 对于最大值的差值：由于是有序的，可以直接最大的值和最小的值是多少，再根据循环找出最大值和最小值的个数1，如果最小值个数等于最大值的个数，即整个序列相等，对数为n* （n-1）/22，如果不相等，则对数为两个数想乘。 注意本算法的关键有两点：1.首先要排序，可以利用1algorithm头文件中的sort函数直接进行排序 2.判断最小值对数的时候要慢慢来，先算出值，再算对数，要格外注意最小值为0的情况。]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[牛客网]构造回文]]></title>
    <url>%2F2018%2F11%2F06%2F%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%9E%84%E9%80%A0%E5%9B%9E%E6%96%87%2F</url>
    <content type="text"><![CDATA[给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; const int maxn = 1010; class Solution &#123; public: void xuliechangdu(string a,string b, int** Maxnum, int **f,int len1,int len2) &#123;//求应删除的个数 reverse(b.begin(), b.end()); for (int m = 0; m &lt; len1; m++) &#123; Maxnum[m][0] = 0; Maxnum[0][m] = 0; &#125; for (int i = 1; i &lt;= len1; i++) &#123; for (int j = 1; j &lt;= len2; j++) &#123; if (a[i - 1] == b[j - 1]) &#123; Maxnum[i][j] = Maxnum[i - 1][j - 1] + 1; f[i][j] = 1; &#125; else if (Maxnum[i - 1][j] &gt; Maxnum[i][j - 1]) &#123; Maxnum[i][j] = Maxnum[i - 1][j]; f[i][j] = 2; &#125; else &#123; Maxnum[i][j] = Maxnum[i][j - 1]; f[i][j] = 3; &#125; &#125; &#125; int result =len1- Maxnum[len1][len2]; cout &lt;&lt; result &lt;&lt; endl;&#125;void printzixulie(string a, int **f,int n,int m,string &amp;re)//打印出回文串&#123; if (m ==0|| n== 0) return; else if (f[n][m] == 1) &#123; printzixulie(a, f, n - 1, m - 1,re); re.push_back(a[n - 1]); cout &lt;&lt; a[n - 1] &lt;&lt; endl; &#125; else if (f[n][m] == 2) printzixulie(a, f, n - 1, m,re); else printzixulie(a, f, n, m - 1,re); &#125;void PrintOneLCS(string &amp;str1, string &amp;str2, int i, int j, int** &amp;veca) &#123; string lcs_str; while (i &gt; 0 &amp;&amp; j &gt; 0) &#123; if (str1[i - 1] == str2[j - 1]) &#123; lcs_str = str1[i - 1] + lcs_str; --i; --j; &#125; else &#123; //如果左边存在LCS就从左边找否则再从右边找 if (veca[i - 1][j] &gt;= veca[i][j - 1]) --i; else --j; &#125; &#125; cout &lt;&lt; lcs_str &lt;&lt; endl;&#125;void allprint(string &amp;s,string &amp;b,int i,int j,int**&amp;Maxnum,string re)&#123; while (i &gt; 0 &amp;&amp; j &gt; 0) &#123; if (s[i - 1] == b[j - 1]) &#123; re = s[i - 1] + re+" " ; //逆向存放 cout &lt;&lt; re &lt;&lt; endl; --i; --j; &#125; else &#123; if (Maxnum[i - 1][j] &gt; Maxnum[i][j - 1]) //向左走 --i; else if (Maxnum[i - 1][j] &lt; Maxnum[i][j - 1]) //向上走 --j; else &#123; //此时向上向右均为LCS的元素 allprint(s, b, i - 1, j, Maxnum, re); allprint(s, b, i, j - 1, Maxnum, re); return; &#125; &#125; &#125; cout&lt;&lt; re &lt;&lt; endl; /*re.insert(lcs_str);*/&#125; int main() &#123; string s; while (cin &gt;&gt; s) &#123; string b = s; string re; string str2=s; reverse(str2.begin(), str2.end()); int len1 = s.length(); int len2 = b.length(); const int maxn = 1010; int **Maxnum; Maxnum = new int *[maxn]; for (int i = 0; i &lt; maxn; i++) Maxnum[i] = new int[maxn]; /* int Maxnum[maxn][maxn];*/ Solution so; int **f; f = new int*[maxn]; for (int j = 0; j &lt; maxn;j++) f[j]=new int[maxn]; //so.xuliechangdu(s,b,Maxnum,f,len1,len2); //so.printzixulie(s,f,len1,len2,re); //so.PrintOneLCS(s, str2, len1, len2, Maxnum); /*so.allprint(s,str2,len1,len2, Maxnum, re);*/ so.zichuanchangdu(s, b, Maxnum, f, len1, len2); cout &lt;&lt; re &lt;&lt; endl; for (int q = 0; q &lt; maxn; q++) &#123; delete[] Maxnum[q]; &#125; delete[]Maxnum; &#125; &#125; 算法这道题可以看成是求解一个序列和此序列倒序列的最长公共子序列长度问题（LCS），解决此类方法的算法核心是动态规划算法 动态规划算法序列A=(a1,a2,a3……an)，序列B=(b1,b2,b3……bm)，它们的LCS为序列C(c1,c2,c3……ck)123如果an=bm,则ck=an=bm，且ck-1是an-1和bm-1的LCS如果an≠bm，则ck≠an，所以c是an-1和bm的LCS如果an≠bm，则ck≠bm，所以c是bm-1和an的LCS 所以，用p(i,j)来表示序列长度123当n=0，或m=0，p(n,m)=0当n，m≠0，且an=bm，p(n,m)=p(n-1,m-1)+1当n，m≠0，且an≠bm，p(n,m)=max&#123;p(n-1,m),p(n,m-1)&#125; 对应上述的xuliechangdu函数 补充当找到回文串时，需要把这个回文串打印出来，利用动态规划的逆想法，如上述的12void printzixulie(string a, int **f,int n,int m,string &amp;re)&#123;&#125; 通过对求取序列长度函数中的tag标号来判断当前下标的字符是否需要输出，同样利用递归的思想，逐个输出tag为1时相对应下标的字符。 注意本文所述的算法仅适用于本题算法，动态规划问题可以求取两个不同字串的公共字符串长度，需要在本文的算法上稍作修改121.对于输入，需要输入两个不同的字符串2.对于输出，由于公共子串不一定是回文，所以本文的输出是从后往前输出，需要注意反序]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[牛客网]字符移位]]></title>
    <url>%2F2018%2F11%2F05%2Fleetcode-%E5%AD%97%E7%AC%A6%E7%A7%BB%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Solution &#123; public: void zifu2(string s) &#123; int len1 = s.length(); char c; int end = len1; for (int i = 0; i &lt; end;) &#123; c = s[i]; if (c &gt;= 'A'&amp;&amp;c &lt;= 'Z') &#123; for (int j = i; j &lt; len1 - 1; j++) &#123; s[j] = s[j + 1]; &#125; s[len1 - 1] = c; end--; &#125; else i++; &#125; cout &lt;&lt; s &lt;&lt; endl; &#125; &#125;; int main() &#123; string s; while (cin &gt;&gt; s) &#123; Solution so; //so.zifu(); so.zifu2(s); &#125; &#125; 算法对字符串进行循环，循环当中的判断不定（这是本题的关键）如果遇到大写字母，则通过类似冒泡排序的方法一样把这个字母放到最后，此时循环的判断是将end值减少1，即将字符串长度减小1，如果不是大写字母，则此时的判断是将i加1，即判断后面一个字母。这样通过对整个字符串遍历就可以完成任务。]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[牛客网]等差数列]]></title>
    <url>%2F2018%2F10%2F19%2Fleetcode-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[如果一个数列S满足对于所有的合法的i,都有S[i + 1] = S[i] + d, 这里的d也可以是负数和零,我们就称数列S为等差数列。小易现在有一个长度为n的数列x,小易想把x变为一个等差数列。小易允许在数列上做交换任意两个位置的数值的操作,并且交换操作允许交换多次。但是有些数列通过交换还是不能变成等差数列,小易需要判别一个数列是否能通过交换操作变成等差数列 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std; class Solution&#123;public: void Dengcha() &#123; int n; int d; int sum=0; cin&gt;&gt;n; int *a=new int[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) &#123; for(int j=n-2;j&gt;=i;j--) &#123; if (a[j]&gt;a[j+1]) &#123; int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; &#125; d=a[1]-a[0]; for(int i=1;i&lt;n;i++) &#123; if( a[i]+d==a[i+1]) sum++; &#125; if (sum==n-2) cout&lt;&lt;"Possible"&lt;&lt;endl; else cout&lt;&lt;"Impossible"&lt;&lt;endl; &#125; &#125;;int main()&#123; Solution s; s.Dengcha(); &#125; 算法首先对数列中的数进行排序，然后算出前两个数的差，即假定为方差，然后再对每个数检验。 改进其中排序算法可以用sort函数代替1sort(a,a+n); 但是要引入 algorithm的头文件。]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[牛客网]彩色砖块]]></title>
    <url>%2F2018%2F10%2F18%2Fleetcode-%E5%BD%A9%E8%89%B2%E7%A0%96%E5%9D%97%2F</url>
    <content type="text"><![CDATA[小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一行。(如果两种方式所对应的砖块颜色序列是相同的,那么认为这两种方式是一样的。) examples = “ABAB”,那么小易有六种排列的结果:“AABB”,”ABAB”,”ABBA”,”BAAB”,”BABA”,”BBAA”其中只有”AABB”和”BBAA”满足最多只有一对不同颜色的相邻砖块 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Solution&#123;public: void Colour() &#123; string s; cin&gt;&gt;s; string a,b,c; int n=0; int len=s.length(); b=s[0]; for(int i=0;i&lt;len;i++) &#123; a=s[i]; if(a!=b) n=n+1; if (n==2) &#123; if (s[i]==s[i-2]) n=1; else cout&lt;&lt;0&lt;&lt;endl; return ; &#125; b=a; &#125; cout&lt;&lt;n+1&lt;&lt;endl; &#125;&#125;;int main()&#123; Solution ss; ss.Colour();&#125; 改进方法12345678910111213141516#include &lt;iostream&gt; using namespace std; int main() &#123; int a[27] = &#123; 0 &#125;, c, sum = 0; while((c=getchar())&gt;32) if (!a[c - 65]) &#123; sum++; a[c - 65] = 1; &#125; if (sum &gt; 2) cout &lt;&lt; 0; else cout &lt;&lt; sum; &#125; 算法26个大写英文字母A~Z的ASCII码值是65～90 getchar()函数该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF。]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[牛客网]最大乘积]]></title>
    <url>%2F2018%2F10%2F15%2Fleetcode-%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大，要求时间复杂度：O(n)，空间复杂度：O(1) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 class Solution &#123;public:void FindMax()&#123; int n; long result; cin &gt;&gt; n; int *a=new int[n];//用指针a指向NEW动态分配的长度N的内存空间 long long max = 1; long long max_sec = 1; long long max_third = 1; long long min = 1; long long min_sec = 1; if (n&lt;3) return ; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; if (a[i] &gt; max) &#123; max_third = max_sec; max_sec = max; max = a[i]; &#125; else if (a[i] &gt; max_sec) &#123; max_third = max_sec; max_sec = a[i]; &#125; else if (a[i] &gt; max_third) &#123; max_third = a[i]; &#125; else if (a[i] &lt; min) &#123; min_sec = min; min = a[i]; &#125; else if (a[i] &lt; min_sec) min_sec = a[i]; long max1 = max * max_sec*max_third; long max2 = max * min*min_sec; if (max1 &gt;= max2) result = max1; else result = max2; &#125; cout&lt;&lt;result&lt;&lt;endl;&#125; &#125;; int main() &#123; Solution s; s.FindMax(); &#125; 算法：因为要求时间复杂度是N，所以只能有循环。当数组大小小于3的时候，直接返回。 最大乘积只有两种可能：1:三个最大正数相乘2：一个最大正数和两个最小负数所以在循环的时候只要找到这五个数。初始化的时候这五个数可以都初始化为1，在循环中，不断改变它们的值。最后将两种情况比较，输出最大值。 易错点：关于数据的溢出，第一次写的时候把所有的数据类型都定义成int型，但是通过率只有22%，这里没有规定数据大小，所以要注意溢出的问题 疑问n=3的情况怎么判断？如果是一个负数两个正数，输出的是什么？代码直接判断了两个正数相乘输出没有报错通过了？ int ,long , long long类型的范围unsigned int 0～4294967295int -2147483648～2147483647unsigned long 0～4294967295long -2147483648～2147483647long long的最大值：9223372036854775807long long的最值：-9223372036854775808unsigned long long的最大值：18446744073709551615 int64的最大值：9223372036854775807 int64的最小值：-9223372036854775808unsigned __int64的最大值：18446744073709551615 32位下，shrot int long分别是2字节，4字节，4字节，longlong是8字节；64位下，long8字节 int是4字节，longlong 8字节。 int是4字节的，一个字节代表8位二进制，所以int的数据类型是32位。所以可以表示2的32次幂的位数，但是数有正有负，所以是-2的32/2=2的31次到2的31次-1]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]生成括号]]></title>
    <url>%2F2018%2F10%2F12%2Fleetcode-%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.给定n对括号，编写一个函数来生成格式正确的括号的所有组合。 exampleFor example, given n = 3, a solution set is: [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] c++代码 对于这种列出所有结果的题首先还是考虑用递归来解123456789101112131415161718192021222324252627282930#include &lt;vector&gt; #include &lt;iostream&gt; using namespace std; class Solution &#123; public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; paren; backtrack("", paren, n, n); return paren;&#125;void backtrack(string out, vector&lt;string&gt; &amp;paren,int left , int right )&#123; if (left &gt; right) return; if (left==0 &amp;&amp; right==0) paren.push_back(out); else &#123; if (left &gt; 0) backtrack(out + "(", paren, left - 1, right); if (right &gt; 0) backtrack(out + ")", paren, left, right - 1); &#125;&#125; &#125;; int main() &#123; Solution s; s.generateParenthesis(3); &#125; 算法左括号3个，右括号3个，所以我们定义两个变量left和right分别表示剩余左右括号的个数，如果在某次递归时，左括号的个数大于右括号的个数，说明此时生成的字符串中右括号的个数大于左括号的个数，即会出现’)(‘这样的非法串，所以这种情况直接返回，不继续处理。如果left和right都为0，则说明此时生成的字符串已有3个左括号和3个右括号，且字符串合法，则存入结果中后返回。如果以上两种情况都不满足，若此时left大于0，则调用递归函数，注意参数的更新，若right大于0，则调用递归函数，同样要更新参数。 注意分成两个函数来写，因为最终要返回的事一个字符串，但是在迭代过程中，需要范围True或False，所以最好分两个函数，一个函数完成总的框架，范围要的结果，定义迭代的函数。另一个函数就是迭代函数的具体声明。 在声明函数backtrack时，容器paren要用引用，否则，每次退出一个递归，paren里的值将恢复最初的值，无法累计。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]ZigZag]]></title>
    <url>%2F2018%2F10%2F07%2Fleetcode-ZigZag%2F</url>
    <content type="text"><![CDATA[The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows字符串“PAYPALISHIRING”以Z字形图案写在给定数量的行上，如下所示:(您可能希望以固定字体显示此图案以获得更好的易读性）然后逐行阅读：“PAHNAPLSIIGYIR” 编写将采用字符串的代码并在给定多行的情况下进行此转换 c++代码12345678910111213141516171819202122232425#include&lt;iostream&gt; using namespace std; class Solution &#123; public: string convert(string s, int numRows) &#123; int length_s = s.length(); int num_z = (numRows * 2 - 2);//一个完整的z的字符个数 if (numRows == 1) return s; string ren; for (int i = 0; i &lt; numRows; i++) &#123; for (int j = 0; j +i&lt; length_s; j = j + num_z) &#123; ren =ren+ s[i + j]; if (i != 0 &amp;&amp; i != numRows - 1&amp;&amp;num_z-i+j&lt;length_s) ren = ren+s[num_z - i + j]; &#125; &#125; return ren; &#125; &#125;; int main() &#123; Solution s; s.convert("PAYPALISHIRING",3); &#125; 算法一个字符串以另外一种形式返回。找到返回字符串的规律 Z的规律：首先看原字符串的长度，再看每个Z需要多少个字符串； 在每一行中再循环每一个Z，循环每个Z的时候，要注意两个边界第一个：是j循环的条件，每行的首个字母的索引是i+j，因此循环每个j的时候，要保证索引小于总长度第二个：除了首末两行，其余的行每个Z都要返回两个字符串，找到这两个字符串的关系，即第二个字符串索引为Z字符个数-i+j，也要保证这个索引小于总长度 有了这两个边界保证，就不需要去考虑完整Z和不完整Z，完全利用索引去和长度的大小去判断字符串。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]----最长回子串]]></title>
    <url>%2F2018%2F10%2F02%2Fleetcode-%E6%9C%80%E9%95%BF%E5%9B%9E%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.给出一个字符串，找到字符串中最长的回文串，你可以假设字符串的最大长度是1000 Example 1:Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2:Input: “cbbd”Output: “bb” 方法一（差劲）：这是我看到题目的第一想法，相当于遍历了整个字符串，然后当找到和索引i相同的索引j时，再往里面判断是否是对称1234567891011121314151617181920212223242526272829303132class Solution:def longestPalindrome(self, s): """ :type s: str :rtype: str """ i = 0 j = 1 max1 = 1 n = len(s) if n == 0: return s else: while i &lt; n - 1: j = i + 1 while j &lt; n - 1: if s[i] == s[j]: j = j + 1 else: break t=0 while i-t&gt;0 and j&lt;=n-1 : if s[i-1-t] == s[j+t]: t=t+1 else: break if j-i+t*2&gt;max1: max1=j-i ans=s[i:j] i = j return ans 方法二（改进）：对上面的算法进行改进，利用找“核”的思想寻找回文字符串，回文字符串的两个重要“核”：aa和aba类似这样形式的字符串，利用 i=j#这样不用遍历整个字符串 先找到这样的核，再往两边判断是否对称，最后返回索引。 class Solution: def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; i=0 max1=1 n=len(s) ans=s[0] while i&lt;n: j=i+1 while j&lt;n: if s[i]==s[j]: j=j+1 else: break k=0 while i-k&gt;0 and j+k&lt;n: if s[i-k-1]==s[j+k]: k=k+1 else: break length=j-i+2*k if length&gt;max1: max1=length ans=s[i-k:j+k] i=j return ans 比较 第一种方法之所以时间复杂度很大是因为两点： 1：没有利用“核”思想，遍历了整个字符串 2：第一种方法从外往里，而第二种方法是从里往外，更加符合回文字符串的特点，即对称性，节省了很多时间。 我相信还有更好的方法]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]移除链表尾端第n个结点]]></title>
    <url>%2F2018%2F09%2F25%2Fleetcode-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%B0%BE%E7%AB%AF%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Given a linked list, remove the n-th node from the end of list and return its head.给定链接列表，从列表末尾删除第n个节点并返回其头部。 一.c++代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt; using namespace std; //Definition for singly-linked list. struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125; &#125;; class Solution &#123; public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; int length1=1; ListNode* p = head; ListNode* q = head; while (p-&gt;next) &#123; length1++; p = p-&gt;next; &#125; int cha = length1 - n; //if (length1 == 1) // return NULL; if (length1 &lt;= n) head = head-&gt;next; else &#123; for (int i = 0; i &lt; (cha - 1); i++) &#123; q = q-&gt;next; &#125; ListNode *t = q-&gt;next; q-&gt;next = t-&gt;next; delete t; &#125; return head; &#125;&#125;; 测试结果1234567891011121314151617int main() &#123; /*Solution *s;*/ ListNode* l1 = new ListNode(1); ListNode *l11 = l1; l11-&gt;next = new ListNode(2); l11 = l11-&gt;next; l11-&gt;next = new ListNode(3); l11 = l11-&gt;next; l11-&gt;next = new ListNode(4); l11 = l11-&gt;next; l11-&gt;next = new ListNode(5); Solution* s = new Solution; s-&gt;removeNthFromEnd(l1, 1); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode]最长不重复子串]]></title>
    <url>%2F2018%2F09%2F21%2FLeetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Given a string, find the length of the longest substring without repeating characters.给定一个字符串，找到最长子字符串的长度而不重复字符。 一.穷举循环法class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; max1=1 n=0 if s==&quot;&quot;: max1=0 return max1 else: for i in s: n=n+1 t=1 p=n for j in s[n:]: if j in s[n-1:p]: max1 = max(t, max1) break else: t=t+1 max1=max(t,max1) p=p+1 return max1 两次循环外循环：遍历字符串中每一个字符内循环：遍历外循环字符串字符之后的每一个字符串，一旦发现和外循环字符重复，就退出内循环每次内循环更新最长字串的值 二.滑动窗口法class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n=len(s) if s==&quot;&quot;: return 0 if n==1: return 1 else: i=0 j=1 max1=1 while (i&lt;n and j&lt;n): if s[j] in s[i:j]: i=i+1 j=i+1 else: j=j+1 max1=max(max1,(j-i)) return max1 solution中给出了一种滑动窗口概念，在java中运用。在窗口中存储当前数据：[i，j）j一开始等于i。当j索引不在窗口里，窗口末端向后滑，并返回j-i当j索引在窗口里，窗口前端向后滑保证遍历每一个字符 运用到python中和第一种方法的想法是完全一样的，但是算法不同，时间复杂度节省了很多遍历每一个字符和子字符串 可以用滑动窗口的想法来遍历，而不需要用两个for循环 三.还有一种更简便的方法看不懂了。。。。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode]水最大容器]]></title>
    <url>%2F2018%2F09%2F20%2FLeetcode-%E6%B0%B4%E6%9C%80%E5%A4%A7%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.给定n个非负整数a1，a2，…，an，其中每个表示坐标（i，ai）处的点。 绘制n条垂直线，使得线i的两个端点位于（i，ai）和（i，0）。 找到两条线，它们与x轴一起形成一个容器，这样容器就含有最多的水。 一.穷举法需要循坏两个列表长度，时间复杂度大 class Solution: def maxArea(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; length=len(height) mian=[] while length&gt;1: for i in range(length-1): minhei=min(height[0],height[i+1]) mianji=minhei*(i+1) mian.append(mianji) resule=max(mian) height.pop(0) length=length-1 return resule clasee=Solution() t=clasee.maxArea([1,8,6,2,5,4,8,3,7]) print(t) 二.（改进）先计算最远处两根之间的面积，然后较短的一根往里面，这样可以保证虽然距离缩小但是面积不一定缩小，长的一根永远在 class Solution: def maxArea(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; length=(len(height)) i=0 j=length-1 result=0 for n in range((length-1)): chang=min(height[i],height[j]) mianji=chang*(j-i) result=max(mianji,result) if height[i]&lt;height[j]: i=i+1 else: j=j-1 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]两数相加]]></title>
    <url>%2F2018%2F09%2F10%2Fleetcode-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself您将获得两个非空链表，表示两个非负整数。 数字以相反的顺序存储，每个节点包含一个数字。 添加两个数字并将其作为链接列表返回。 您可以假设这两个数字不包含任何前导零，除了数字0本身 一.python代码123456789101112131415161718192021222324252627282930313233class Solution: def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ q=l1 p=l2 hum=ListNode(0) w=hum tag=0 while (q or p): if q!=None: x=q.val q=q.next else: x=0 if p!=None: y=p.val p=p.next else: y=0 sum=((x+y+tag)%10) if ((x+y+tag)&gt;9): tag=1 else: tag=0 w.next=ListNode(sum) w=w.next if tag==1: w.next=ListNode(tag) return hum.next 二.C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; int sum; int tag=0; ListNode *num=new ListNode(0); ListNode *w = num; while (l1||l2) &#123; int x; int y; if (l1) &#123; x = l1-&gt;val; l1 = l1-&gt;next; &#125; else x = 0; if (l2) &#123; y = l2-&gt;val; l2 = l2-&gt;next; &#125; else y = 0; sum = (x+y+tag)%10; if ((x + y + tag) &gt;= 10) tag = 1; else tag = 0; /*ListNode* pnew = new ListNode(sum);*/ w-&gt;next = new ListNode(sum); w = w-&gt;next; /* w-&gt;next = pnew; w = pnew;*/ &#125; /*if (tag==1) w-&gt;next = new ListNode(tag);*/ if (tag == 1) &#123; ListNode* pnew = new ListNode(tag); w-&gt;next = pnew; &#125; return num-&gt;next; &#125; &#125;; 链表将一个链表赋值给另一个，他们的next地址指向永远相同。调用一个链表的next，就是将链表后面所有的都打印出来。链表一定要赋值了，才有next的地址，不然链表的next就是空。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]继承]]></title>
    <url>%2F2018%2F05%2F30%2FC-%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承因为本科的时候接触过一段时间java，对继承这个概念印象深刻。 继承限定词 public：父类怎样子类就怎样 class CChild: public CPeaple { }; protected:继承之后，父类的public降级成protected，父类中的protected和private不变父类中的属性不会改变 class CChild: protected CPeaple { }; private：继承之后，父类中都降级成private class CChild: private CPeaple { }; 成员的继承无参构造函数：继承构造的调用顺序：先父类再子类； 含参构造函数如果父类有构造函数，且有参数，子类的构造函数一定要写出来。参数在参数列表传递 class CFather { public: CFather(int a); { } } class CSon:public CFather { public: int a; CSon():CFather(1); { } }; 参数传递只能两级之间。如果CFather继承了别的类，只需在CFather类中加入参数列表，和CSon没关系。当有多个构造函数时，根据参数列表的个数决定调用哪个构造函数 析构函数析构函数调用顺序：先子类再父类 覆盖在子类中有和父类中同名的数据成员，把父类中的覆盖，如果想在子类中用父类的数据成员：类内： cout&lt;&lt;CFather::a&lt;&lt;end; 类外： CSon so； cout&lt;&lt;so.CFather::a&lt;&lt;endl； 子类函数和父类函数同名，并不是重载，调用的时候必须使用CFather::来调用父类的函数。友元函数不能被继承 多态和虚函数多态只针对指针对象，虚函数只针对于函数成员；父类的指针调用子类的函数 CFather *fa = new CSon; fa-&gt;show()//普通函数只能调用父类自己的成员 虚函数virtual： //父类： virtual void show()//虚函数 { cout&lt;&lt;&quot;father&quot;&lt;&lt;endl } //子类： void show() { cout&lt;&lt;&quot;son&quot;&lt;&lt;endl } //main： CFather *fa = new CSon; fa-&gt;show()//用父类的指针调用子类的成员 只有函数名字一样，才能达到这个虚函数调用效果。 重写 针对虚函数； 1.父类是虚函数，子类重写的函数，默认是虚函数； 返回值类型必须相同 2.特殊情况（协变）：当返回的是当前类的引用或者指针，返回值的类型可以是各自类类型。3.虚函数不能是内联函数4.构造函数不能是虚函数 虚表CFather* fa=new CSon; fa-&gt;show; *(int*)fa//获得的是虚表的首地址 把对象的首地址转成int （四字节） ，然后取对象首地址的地址 *(int*)*(int*)fa//获得的是虚表的第一个的地址内容（fun） *((int*)*(int*)fa+1)//获得的是续表第二个的地址内容（show） 虚表的首地址并不知道是什么类型，所以要先转换成int*,然后递增 代码实现： typedef void (*p)(); ((p)(*(int*)*(int*)fa+0)))()//调用 取内容 fun 虚析构多态中，如果释放父类指针，只会调用父类的析构函数，变成虚析构后，子类父类都调用]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]初始化和宏定义]]></title>
    <url>%2F2018%2F05%2F28%2FC-%E5%9F%BA%E7%A1%80-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[初始化，宏定义，常函数和静态成员 初始化和赋值的区别初始化：变量和对象产生的时候赋予一个值，伴随性质赋值：产生之后赋予一个值，随意性质数组的赋值只能单个赋值 int b[12]; b[0]=1; b[1]=2 引用和const一定要初始化 初始化列表class CStu { public: int a; float f; //第一种 CStu():a(12),f(12.23f)//初始化列表 { } //第二种 CStu(int b,float c):a(b),f(c)//初始化的顺序只和声明顺序有关，和书写顺序无关 { } //第三种 CStu():a(12),f(a)//成员间的初始化，f和a要一个类型 { } } 引用和const初始化class CStu { public: int b; int &amp;a; //第一种 CStu(int c):a(b),b(c)//a(c),b(c)这样赋值不行，在构造函数可以输出，但main不行。初始化列表 { } c是局部变量，给b赋值完后，它的值就不存在了 //第二种 CStu(int &amp;c):a(c),b(c) 主函数： int d=12; CStu stu(d) d的作用范围大，一直在 数组和结构体使用初始化列表数组int a[4]; //第一种 CStu():a()//输出都为0，但不是所有编译器都允许 //第二种 CStu() { for(int i=0;i&lt;4;i++) { a[i]=0; } } //第三种 CStu() { memset(a,0,16)//16:占4*4个字节 } 结构体1. struct STU { int i; float f; }; 结构体可以直接赋值 在main函数： STU st={1,12.23f}; STU st1=st//结构体可以这样赋值 2.有疑问在类里调用一个结构体 STU st; CStu(STU sd):st(sd) { } 在main函数里 STU sf={12,12.12f} CStu stu(sf) 宏定义用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本(1)简单的宏定义: #define &lt;宏名&gt; &lt;字符串&gt;例： #define PI 3.1415926 (2) 带参数的宏定义 #define &lt;宏名&gt; (&lt;参数表&gt;) &lt;宏体&gt;例： #define A(x) x 如果是自己编程使用宏替换，则在使用简单宏定义时，当字符串中不只一个符号时，加上括号表现出优先级，如果是带参数的宏定义，则要给宏体中的每个参数加上括号，并在整个宏体上再加一个括号。看到这里，不禁要问，用宏定义这么麻烦，这么容易出错，可不可以摒弃它， 那让我们来看一下在C语言中用宏定义的好处吧。 常函数int a; void show()const { a=12;//报错，常函数不能修改数据成员 int b=12 //内部允许这样 } 常对象： const CStu stu 只能调用常函数，不能调用普通函数 静态成员static int a; static void fun(); 类外初始化，静态成员受private修饰 类外： int CStu::a=13//类外不用加static 输出： cout&lt;&lt;CStu::a&lt;&lt;endl //或者 CStu st; st.a; 静态函数不能调用普通成员静态成员时其他对象公有的，都可以访问 不使用for循环累加class CStu { public: static int b; CStu() { b++; } } int main() { CStu st[5];//5个对象，调用5个构造函数，b++五次，因为静态成员是共享的 cout&lt;&lt;CStu::b&lt;&lt;endl }]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]拷贝构造和重载]]></title>
    <url>%2F2018%2F05%2F27%2FC-%E5%9F%BA%E7%A1%80-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[函数重载和默认参数，拷贝构造，符号重载 默认参数值void fun(int a=12,char c=&apos;c&apos;) { } //全部指定 void fun1(int a ,char c,float f==12.1) { } 部分指定，从右向左连续指定 函数调用，有默认值的参数可以不用传递实参有默认值，传递实参回覆盖默认值 函数重载同一作用域内：函数声明向下函数名相同，参数个数或者类型不同返回值不能作为函数重载的条件当一个函数有两个形参，一个是默认参数，另一个函数重载也是两个形参，会造成调用不明确 拷贝构造c++不允许拷贝构造函数传值参数构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值 public： CStu() { CStu(const CStu&amp; a) } 何时调用1.创建对象并初始化为同类对象 CStu a; 1 CStu a1(a); 2 CStu a2=a; 3 CStu a3=CStu(a) 4 CStu *a3=new CStu(a) 5 a4=a//这个不会调用 2 程序生成对象副本 //1:将以个对象作为实参传递给一个非引用类型的形参， //对象以值传递的方式传入函数参数 void fun(CStu a1)//类外函数 //调用 fun(a) 调用过程： （1）当对象a传入fun函数的形参时，会产生一个临时变量，我们把这个临时变量叫做a1； （2）调用拷贝构造函数，把test的值赋给a1，类似于 Cstu a1(a) （3）等fun函数执行完，析构掉a1对象 //2从一个返回类型为非引用类型的函数返回一个对象 // 对象以值传递的方式从函数返回 CStu fun() { CStu a ; return a;//返回值相当于一个临时变量，调用拷贝构造 } //调用 fun( ) 调用过程： （1）当执行到return时，产生一个临时变量XX （2）调用拷贝构造函数把a的值赋给XX，有点像CStu XX（a） （3）拷贝构造函数执行到最后，析构掉a局部变量 （4）fun函数执行完析构掉XX 拷贝初始化和直接初始化拷贝初始化：把右边的运算对象拷贝到正在创建的对象中直接初始化：使用普通的函数匹配来选择和我们提供参数最匹配的构造函数 情况默认的复制构造函数，逐个复制非静态成员（浅复制）复制的是成员的值。 stcrpy_s(c,4,&apos;abc&apos;)//4:元素个数 默认拷贝构造可以不写，执行的就是复制内容 CStu(const CStu &amp;a) { this-&gt;b=a.b; stcrpy_c(this-&gt;c,4,a.c) //必须写全复制内容 } 同一个类的多个对象，内存排布一样，地址不同 浅拷贝int *a; CStu() { a=new int[2];//指针可以指向数组的首地址 a[0]=1; a[1]=2;//数组别忘了在析构函数释放空间 } //mian： CStu st; CStu st1=st; 程序会报错，原因如下：浅拷贝只是将成员的值进行赋值，两个指针指向一个空间，销毁对象时，析构函数会释放两次，报错。解决方法利用深拷贝 深拷贝对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间 CStu(const CStu&amp; b) { this.a-&gt;new int[2] this.a[0]=b.a[0] this.a[1]=b.a[1] } //mian： CStu st; CStu st1=st; 让st1有自己的空间 可以利用函数 mencpy(this.a,b.c,8)//8表示字节 还有一个方法明天试一下 p = new int; // 为新对象重新动态分配空间 *p = *(r.p); 指针成员要用深拷贝，不能直接赋值 返回值为引用我们的重载运算符返回void、返回对象本身、返回对象引用都是可以的，并不是说一定要返回一个引用，只不过在不同的情况下需要不同的返回值。主要是两个原因：1.允许进行连续赋值 2.防止返回对象的时候调用拷贝构造函数和析构函数导致不必要的开销，降低赋值运算符的效率。 重载运算符返回地址类内重载！！ int a=1; double b=1.2; int nerror = -1; void* operator [](int n) { switch(n) { case 0: return &amp;a; case 1: return &amp;b; } return &amp;nerror; } //main cout&lt;&lt; st[1];//取出了a值得地址 //如果要取出地址相对应的值，利用*取值 cout&lt;&lt;*st[1];//报错，因为返回的void类型没有确定的大小 cout&lt;&lt;*(double*)st[1];//取出相应的值 void* ：通用类型指针，其他类型指针可以往它转换。如果要对他赋值，也要有类型限制 *(double*)st[1]=14； cout&lt;&lt;*(double*)st[1]; 不推荐这样使用，还是推荐使用引用返回值 int&amp; operator [](int n) 自加自减运算符前置++： int operator ++ (CStu&amp; st) { st.age+=1; return st.age; } //main CStu st; cout&lt;&lt;++st; 后置++： int operator ++ (CStu&amp; st，int n)//int n 理解成一个标记，有int n就是后置++ { int a=st.age; st.age+=1; return a; } //main CStu st; cout&lt;&lt;st++; 重载类型转换operator int() const//不改变对象内容 { return a; } 没有返回类型！！但是要写返回值必须是类内定义； 赋值运算符必须定义为成员函数赋值运算符通常应该返回一个指向其左侧运算对象的引用]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]一些函数]]></title>
    <url>%2F2018%2F05%2F26%2FC-%E5%9F%BA%E7%A1%80-%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[析构函数，构造函数，友元和接口函数等 析构函数1~CStu（）//只有一个，不能重载，不能有参数 对象声明周期结束时，自动调用后括号}或者碰到return构造函数是遇到声明语句马上调用12345678 &#123; CStu stu;//执行到这一步，直接调用构造函数 &#125;//执行到这一步，调用析构函数或者return``` 指针对象遇到delete才调用析构函数```cpp Cstu* stu = new CStu; delete stu; 临时对象,作用鱼仅限这一行代码，创建完直接调用析构函数123456789101112 CStu(12)//在内部是创建了一个对象 CStu tu(12)``` **malloc free和 new delete区别**&lt;br&gt;## tihs 指针this指针创建对象时才有（不是成员）&lt;br&gt;当局部变量和外部变量同名```cpp int a; CStu(int a) &#123; this-&gt;a=a &#125; 是成员函数的隐含参数1234567CStu* GetAddr()&#123; return this&#125;//main函数：CStu* p=st.GetAddr()cout&lt;&lt;p&lt;&lt;endl st对象包含对象地址 构造函数class CStu { public: int age; float f;//只有静态常量才能在类中初始化 void fun()//相当于类的初始化函数 { age=12; f=12.12f; } CStu()//构造函数，无返回值 { age=13; f=12.13f; } } int main() { CStu stu; stu.fun(); cout &lt;&lt; stu.a &lt;&lt; &quot; &quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } //需要先调用fun函数，才能调用变量a， 如果有构造函数，可以直接调用 CStu stu; cout &lt;&lt; stu.a &lt;&lt; &quot; &quot; &lt;&lt; endl; 1.作用 2.执行时间：对象创建时调用 CStu *stu = new CStu; stu-&gt;age; 数组new是才能创建对象调用构造函数 构造函数的类型带参数Cstu(int a,float b)//可以指定默认值 { age=a; f=b; } 如果构造函数有参数，在声明时一定要传参 CStu stu(12,12.23f);//不传参数不要括号 可以有多个构造函数（重载） 友元在类里面声明一个友元 Class CStu { public: int a; float b; friend class CTech;//友元类 friend void fun();//友元函数，外部fun函数就是调用类里面的私有和protected变量 } Class CTech { } //友元类去使用私有变量 不受访问修饰符的限制，但是破坏了类的封装性 接口函数Class CStu { private: int age; public: void set()//接口函数 { age=13; } int get()//接口函数 { return age; } } int main() { CStu stu; stu.set(); int a=stu.get(); } age是类里面的私有变量，为了类的封装性。采用接口函数]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]指针和引用]]></title>
    <url>%2F2018%2F05%2F26%2FC-%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[指针，引用，引用变量，引用做参数和返回值，指针和引用的区别 指针new申请指针空间申请单个空间的时候，可以直接初始化但是申请数组时，可以使用memset赋值 delete释放指针在释放数组时，要加方括号 #include &lt;iostream&gt; using namespace std; int main() { ////申请单个空间 //int *p = new int;//new+type 类型匹配上 也可以直接初始化 new int(12) //int *p1=malloc(sizeof(int));c语言！ //char *p = new char; //*p = 12;//写 //cout &lt;&lt; *p &lt;&lt; endl;//读 //delete p;//释放 //申请数组 int *p = new int[5]; memset(p,0,5*4)//赋值数组，5个值，每个int占4个字节，总共20个字节 //int *p1 = malloc(5 * 4); c语言 p[0] = 12; p[1] = 11; cout &lt;&lt; p[0] &lt;&lt; &quot; &quot; &lt;&lt; p[1] &lt;&lt; endl; system(&quot;pause&quot;); delete[]p;//释放数组P 要方括号 return 0; } *作用1 在申明一个变量的时候，*指针变量2 地址操作符 读写3 数字 表示乘法 对内存的操作读 写 取地址&amp; 引用给变量取别名 int a=12; int &amp;c=a;//声明变量a的一个引用c，c时变量a的一个别名 c=13//a的值也改变了 引用的时候一定要初始化可以被多个变量引用与赋值概念不同 指针这个和指针不同 *p=&amp;a; p指向的是a的地址，而不是a本身 但是取别名的话，直接关联本身 其他类型的引用常量的引用const int&amp; a = 12; 不可以修改a的值，只能读 数组的引用1 一维数组： int ar[12]; int (&amp;p)[12]=ar;//引用 类型 2 二维数组 int arr[2][3]; int (&amp;p)[2][3]=arr; 指针的引用int b=12; int *p=&amp;b; int *(&amp;p1)=p; 引用做参数void fun(int&amp; a) { a=13; count&lt;&lt;a&lt;&lt;endl; } void fun1(int a) { a=14; coutn&lt;&lt;a&lt;&lt;endl; } void fun2(int* a) { *a=15; } int main() { int b=12; fun(b); fun1(b); fun2(&amp;b); return 0; } 1.调用fun函数时，a初始化成b,a和b关联同一个空间,在函数fun里给a赋值，调用时，b的值也改变成和a一样 2.调用fun1函数时，把b赋值给了a，给a的空间传递了一个b的值，fun1函数里面a赋值，并不会改变b 3.c语言中，通过调用指针改变外部的值,如图： （引用）交换两个变量的值void exchange(int&amp; a,int&amp; b) { int temp=a; a=b; b=temp; } 不引用直接传入无法改变 指针传入也可以改变两个变量的值 void exchange(int*a,int*b) { int *temp=*a; *a=*b; *b=*temp; } 引用做返回值int&amp; fun() { int a=12; return a; } int main() { int&amp; b=fun(); cout&lt;&lt;b&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 第九行调用了局部变量后，a的内容空间销毁，第十行是非法空间操作！！不要引用局部变量 引用不占存储空间，指针占空间 &amp;作用： 1.变量前加 做引用 2.取地址 3.与运算 引用做参数void fun(int&amp; a) { a=13; count&lt;&lt;a&lt;&lt;endl; } void fun1(int a) { a=14; coutn&lt;&lt;a&lt;&lt;endl; } void fun2(int* a) { *a=15; } int main() { int b=12; fun(b); fun1(b); fun2(&amp;b); return 0; } 1.调用fun函数时，a初始化成b,a和b关联同一个空间,在函数fun里给a赋值，调用时，b的值也改变成和a一样 2.调用fun1函数时，把b赋值给了a，给a的空间传递了一个b的值，fun1函数里面a赋值，并不会改变b 3.c语言中，通过调用指针改变外部的值,如图： （引用）交换两个变量的值void exchange(int&amp; a,int&amp; b) { int temp=a; a=b; b=temp; } 不引用直接传入无法改变 指针传入也可以改变两个变量的值 void exchange(int*a,int*b) { int *temp=*a; *a=*b; *b=*temp; } 引用引用只是别名，不是实体类型（也就是说c++编译器不为引用单独分配内存空间），对一个对象的引用，就是直接对这个对象的操作。 （1）引用必须初始化(引用必须指向所引用的对象) int a = 3;&lt;br&gt; int&amp; ra = a;&lt;br&gt; int &amp;b ;//错误，引用必须初始化 (3)引用不能更换目标 int&amp; ra = a; // int&amp; ra = b;//错误，多次初始化 引用的使用场合？（一）引用型参数（函数形参只是实参的别名，也就是说形参和实参是同一个对象）使用引用型参数有两个好处：（1）因为函数形参和实参是同一个对象，也就不存在对象复制，避免了对象的开销。（2）可以在修改形参的同时对实参的修改。因为不存在拷贝构造所以，可以提高c++程序的执行效率 （2）引用型返回值 从函数中返回引用，一定要保证在函数返回以后，被引用的目标一直有效，也就是不能返回函数体内的局部对象的引用，局部对象离开作用域就会被析构掉，所以不能返回对函数体内的局部对象的引用。 区别和联系指针可以不初始化，可以改变它指向的目标。]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]结构体和类]]></title>
    <url>%2F2018%2F05%2F25%2FC-%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[一些基础知识点，结构体和类理论 基础知识点主函数：应用程序入口一个项目只能有一个主函数 主函数形式1:int main()c++标准形式2:int main(void) c标准形式3:int main(int argc,char* argv[ ]) 命令行参数4:main() c5:void main() (不提倡) 输出 输入cout可以连续输出，自动识别类型&lt;&lt;’a’&lt;&lt;21&lt;&lt;”dddd”“” 字符串‘’字符小数自动识别成double，所以定义浮点数时，要在最后加ffloat b=12.122f endl换行，并且清空刷新缓冲区\n换行符依旧可以用 c结构体结构体中不能直接有函数成员，但可以通过一定的语法间接调用函数，比如函数指针声明结构体变量必须有struct关键字123456789101112131415161718#include &lt;stdio.h&gt;typedef struct Node&#123; int m; void(*p)();//函数指针&#125;;void fun()&#123; printf("hello");&#125;int main(void)&#123; struct Node a = &#123; 1,fun &#125;; a.p();//调用函数 return 0;&#125;; 在C中定义一个结构体类型要用typedef: 1234typedef struct Student &#123; int a; &#125;Stu; 于是在声明变量的时候就可：Stu stu1;(如果没有typedef就必须用struct Student stu1;来声明)这里的Stu实际上就是struct Student的别名。Stu==struct Student1234typedef struct&#123;int a;&#125;Stu; 另外这里也可以不写Student（于是也不能struct Student stu1;了，必须是Stu stu1;） c++ 结构体在c++中如果用typedef的话，又会造成区别：1234struct Student &#123; int a; &#125;stu1;//stu1是一个变量 1234typedef struct Student2 &#123; int a; &#125;stu2;//stu2是一个结构体类型=struct Studen 声明变量不用struct可以放函数成员12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;struct Node&#123; int m; void fun() &#123; printf("hello"); &#125;&#125;;int main() &#123; Node a; a.fun(); system("pause"); return 0;&#125;;]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lujing--Blog]]></title>
    <url>%2F2018%2F01%2F24%2FLujing-Blog%2F</url>
    <content type="text"><![CDATA[之前弄过一次博客，后来被我荒废了，主题配置文件还出了错，这次就重新来过。 作为一名研一的工科女生]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
