<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[leetcode]移除链表尾端第n个结点]]></title>
    <url>%2F2019%2F01%2F25%2Fleetcode-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%B0%BE%E7%AB%AF%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Given a linked list, remove the n-th node from the end of list and return its head.给定链接列表，从列表末尾删除第n个节点并返回其头部。 一.c++代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt; using namespace std; //Definition for singly-linked list. struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125; &#125;; class Solution &#123; public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; int length1=1; ListNode* p = head; ListNode* q = head; while (p-&gt;next) &#123; length1++; p = p-&gt;next; &#125; int cha = length1 - n; //if (length1 == 1) // return NULL; if (length1 &lt;= n) head = head-&gt;next; else &#123; for (int i = 0; i &lt; (cha - 1); i++) &#123; q = q-&gt;next; &#125; ListNode *t = q-&gt;next; q-&gt;next = t-&gt;next; delete t; &#125; return head; &#125;&#125;; 测试结果1234567891011121314151617int main() &#123; /*Solution *s;*/ ListNode* l1 = new ListNode(1); ListNode *l11 = l1; l11-&gt;next = new ListNode(2); l11 = l11-&gt;next; l11-&gt;next = new ListNode(3); l11 = l11-&gt;next; l11-&gt;next = new ListNode(4); l11 = l11-&gt;next; l11-&gt;next = new ListNode(5); Solution* s = new Solution; s-&gt;removeNthFromEnd(l1, 1); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]----最长回子串]]></title>
    <url>%2F2018%2F10%2F02%2Fleetcode-%E6%9C%80%E9%95%BF%E5%9B%9E%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.给出一个字符串，找到字符串中最长的回文串，你可以假设字符串的最大长度是1000 Example 1:Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2:Input: “cbbd”Output: “bb” 方法一（差劲）：这是我看到题目的第一想法，相当于遍历了整个字符串，然后当找到和索引i相同的索引j时，再往里面判断是否是对称1234567891011121314151617181920212223242526272829303132class Solution:def longestPalindrome(self, s): """ :type s: str :rtype: str """ i = 0 j = 1 max1 = 1 n = len(s) if n == 0: return s else: while i &lt; n - 1: j = i + 1 while j &lt; n - 1: if s[i] == s[j]: j = j + 1 else: break t=0 while i-t&gt;0 and j&lt;=n-1 : if s[i-1-t] == s[j+t]: t=t+1 else: break if j-i+t*2&gt;max1: max1=j-i ans=s[i:j] i = j return ans 方法二（改进）：对上面的算法进行改进，利用找“核”的思想寻找回文字符串，回文字符串的两个重要“核”：aa和aba类似这样形式的字符串，利用 i=j#这样不用遍历整个字符串 先找到这样的核，再往两边判断是否对称，最后返回索引。 class Solution: def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; i=0 max1=1 n=len(s) ans=s[0] while i&lt;n: j=i+1 while j&lt;n: if s[i]==s[j]: j=j+1 else: break k=0 while i-k&gt;0 and j+k&lt;n: if s[i-k-1]==s[j+k]: k=k+1 else: break length=j-i+2*k if length&gt;max1: max1=length ans=s[i-k:j+k] i=j return ans 比较 第一种方法之所以时间复杂度很大是因为两点： 1：没有利用“核”思想，遍历了整个字符串 2：第一种方法从外往里，而第二种方法是从里往外，更加符合回文字符串的特点，即对称性，节省了很多时间。 我相信还有更好的方法]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode]最长不重复子串]]></title>
    <url>%2F2018%2F09%2F21%2FLeetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Given a string, find the length of the longest substring without repeating characters.给定一个字符串，找到最长子字符串的长度而不重复字符。 一.穷举循环法class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; max1=1 n=0 if s==&quot;&quot;: max1=0 return max1 else: for i in s: n=n+1 t=1 p=n for j in s[n:]: if j in s[n-1:p]: max1 = max(t, max1) break else: t=t+1 max1=max(t,max1) p=p+1 return max1 两次循环外循环：遍历字符串中每一个字符内循环：遍历外循环字符串字符之后的每一个字符串，一旦发现和外循环字符重复，就退出内循环每次内循环更新最长字串的值 二.滑动窗口法class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n=len(s) if s==&quot;&quot;: return 0 if n==1: return 1 else: i=0 j=1 max1=1 while (i&lt;n and j&lt;n): if s[j] in s[i:j]: i=i+1 j=i+1 else: j=j+1 max1=max(max1,(j-i)) return max1 solution中给出了一种滑动窗口概念，在java中运用。在窗口中存储当前数据：[i，j）j一开始等于i。当j索引不在窗口里，窗口末端向后滑，并返回j-i当j索引在窗口里，窗口前端向后滑保证遍历每一个字符 运用到python中和第一种方法的想法是完全一样的，但是算法不同，时间复杂度节省了很多遍历每一个字符和子字符串 可以用滑动窗口的想法来遍历，而不需要用两个for循环 三.还有一种更简便的方法看不懂了。。。。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode]水最大容器]]></title>
    <url>%2F2018%2F09%2F20%2FLeetcode-%E6%B0%B4%E6%9C%80%E5%A4%A7%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.给定n个非负整数a1，a2，…，an，其中每个表示坐标（i，ai）处的点。 绘制n条垂直线，使得线i的两个端点位于（i，ai）和（i，0）。 找到两条线，它们与x轴一起形成一个容器，这样容器就含有最多的水。 一.穷举法需要循坏两个列表长度，时间复杂度大 class Solution: def maxArea(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; length=len(height) mian=[] while length&gt;1: for i in range(length-1): minhei=min(height[0],height[i+1]) mianji=minhei*(i+1) mian.append(mianji) resule=max(mian) height.pop(0) length=length-1 return resule clasee=Solution() t=clasee.maxArea([1,8,6,2,5,4,8,3,7]) print(t) 二.（改进）先计算最远处两根之间的面积，然后较短的一根往里面，这样可以保证虽然距离缩小但是面积不一定缩小，长的一根永远在 class Solution: def maxArea(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; length=(len(height)) i=0 j=length-1 result=0 for n in range((length-1)): chang=min(height[i],height[j]) mianji=chang*(j-i) result=max(mianji,result) if height[i]&lt;height[j]: i=i+1 else: j=j-1 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]两数相加]]></title>
    <url>%2F2018%2F09%2F10%2Fleetcode-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself您将获得两个非空链表，表示两个非负整数。 数字以相反的顺序存储，每个节点包含一个数字。 添加两个数字并将其作为链接列表返回。 您可以假设这两个数字不包含任何前导零，除了数字0本身 一.python代码123456789101112131415161718192021222324252627282930313233class Solution: def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ q=l1 p=l2 hum=ListNode(0) w=hum tag=0 while (q or p): if q!=None: x=q.val q=q.next else: x=0 if p!=None: y=p.val p=p.next else: y=0 sum=((x+y+tag)%10) if ((x+y+tag)&gt;9): tag=1 else: tag=0 w.next=ListNode(sum) w=w.next if tag==1: w.next=ListNode(tag) return hum.next 二.C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; int sum; int tag=0; ListNode *num=new ListNode(0); ListNode *w = num; while (l1||l2) &#123; int x; int y; if (l1) &#123; x = l1-&gt;val; l1 = l1-&gt;next; &#125; else x = 0; if (l2) &#123; y = l2-&gt;val; l2 = l2-&gt;next; &#125; else y = 0; sum = (x+y+tag)%10; if ((x + y + tag) &gt;= 10) tag = 1; else tag = 0; /*ListNode* pnew = new ListNode(sum);*/ w-&gt;next = new ListNode(sum); w = w-&gt;next; /* w-&gt;next = pnew; w = pnew;*/ &#125; /*if (tag==1) w-&gt;next = new ListNode(tag);*/ if (tag == 1) &#123; ListNode* pnew = new ListNode(tag); w-&gt;next = pnew; &#125; return num-&gt;next; &#125; &#125;; 链表将一个链表赋值给另一个，他们的next地址指向永远相同。调用一个链表的next，就是将链表后面所有的都打印出来。链表一定要赋值了，才有next的地址，不然链表的next就是空。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lujing--Blog]]></title>
    <url>%2F2018%2F01%2F24%2FLujing-Blog%2F</url>
    <content type="text"><![CDATA[之前弄过一次博客，后来被我荒废了，主题配置文件还出了错，这次就重新来过。 作为一名研一的工科女生]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
