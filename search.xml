<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[leetcode]----最长回子串]]></title>
    <url>%2F2018%2F10%2F21%2Fleetcode-%E6%9C%80%E9%95%BF%E5%9B%9E%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.给出一个字符串，找到字符串中最长的回文串，你可以假设字符串的最大长度是1000 Example 1:Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2:Input: “cbbd”Output: “bb” 方法一（差劲）：这是我看到题目的第一想法，相当于遍历了整个字符串，然后当找到和索引i相同的索引j时，再往里面判断是否是对称1234567891011121314151617181920212223242526272829303132class Solution:def longestPalindrome(self, s): """ :type s: str :rtype: str """ i = 0 j = 1 max1 = 1 n = len(s) if n == 0: return s else: while i &lt; n - 1: j = i + 1 while j &lt; n - 1: if s[i] == s[j]: j = j + 1 else: break t=0 while i-t&gt;0 and j&lt;=n-1 : if s[i-1-t] == s[j+t]: t=t+1 else: break if j-i+t*2&gt;max1: max1=j-i ans=s[i:j] i = j return ans 方法二（改进）：对上面的算法进行改进，利用找“核”的思想寻找回文字符串，回文字符串的两个重要“核”：aa和aba类似这样形式的字符串，利用 i=j#这样不用遍历整个字符串 先找到这样的核，再往两边判断是否对称，最后返回索引。 class Solution: def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; i=0 max1=1 n=len(s) ans=s[0] while i&lt;n: j=i+1 while j&lt;n: if s[i]==s[j]: j=j+1 else: break k=0 while i-k&gt;0 and j+k&lt;n: if s[i-k-1]==s[j+k]: k=k+1 else: break length=j-i+2*k if length&gt;max1: max1=length ans=s[i-k:j+k] i=j return ans 比较 第一种方法之所以时间复杂度很大是因为两点： 1：没有利用“核”思想，遍历了整个字符串 2：第一种方法从外往里，而第二种方法是从里往外，更加符合回文字符串的特点，即对称性，节省了很多时间。 我相信还有更好的方法]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lujing--Blog]]></title>
    <url>%2F2018%2F01%2F24%2FLujing-Blog%2F</url>
    <content type="text"><![CDATA[之前弄过一次博客，后来被我荒废了，主题配置文件还出了错，这次就重新来过。 作为一名研一的工科女生]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode]最长不重复子串]]></title>
    <url>%2F2017%2F10%2F21%2FLeetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Given a string, find the length of the longest substring without repeating characters.给定一个字符串，找到最长子字符串的长度而不重复字符。 一.穷举循环法class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; max1=1 n=0 if s==&quot;&quot;: max1=0 return max1 else: for i in s: n=n+1 t=1 p=n for j in s[n:]: if j in s[n-1:p]: max1 = max(t, max1) break else: t=t+1 max1=max(t,max1) p=p+1 return max1 两次循环外循环：遍历字符串中每一个字符内循环：遍历外循环字符串字符之后的每一个字符串，一旦发现和外循环字符重复，就退出内循环每次内循环更新最长字串的值 二.滑动窗口法class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n=len(s) if s==&quot;&quot;: return 0 if n==1: return 1 else: i=0 j=1 max1=1 while (i&lt;n and j&lt;n): if s[j] in s[i:j]: i=i+1 j=i+1 else: j=j+1 max1=max(max1,(j-i)) return max1 solution中给出了一种滑动窗口概念，在java中运用。在窗口中存储当前数据：[i，j）j一开始等于i。当j索引不在窗口里，窗口末端向后滑，并返回j-i当j索引在窗口里，窗口前端向后滑保证遍历每一个字符 运用到python中和第一种方法的想法是完全一样的，但是算法不同，时间复杂度节省了很多遍历每一个字符和子字符串 可以用滑动窗口的想法来遍历，而不需要用两个for循环 三.还有一种更简便的方法看不懂了。。。。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode]水最大容器]]></title>
    <url>%2F2017%2F10%2F20%2FLeetcode-%E6%B0%B4%E6%9C%80%E5%A4%A7%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.给定n个非负整数a1，a2，…，an，其中每个表示坐标（i，ai）处的点。 绘制n条垂直线，使得线i的两个端点位于（i，ai）和（i，0）。 找到两条线，它们与x轴一起形成一个容器，这样容器就含有最多的水。 一.穷举法需要循坏两个列表长度，时间复杂度大 class Solution: def maxArea(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; length=len(height) mian=[] while length&gt;1: for i in range(length-1): minhei=min(height[0],height[i+1]) mianji=minhei*(i+1) mian.append(mianji) resule=max(mian) height.pop(0) length=length-1 return resule clasee=Solution() t=clasee.maxArea([1,8,6,2,5,4,8,3,7]) print(t) 二.（改进）先计算最远处两根之间的面积，然后较短的一根往里面，这样可以保证虽然距离缩小但是面积不一定缩小，长的一根永远在 class Solution: def maxArea(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; length=(len(height)) i=0 j=length-1 result=0 for n in range((length-1)): chang=min(height[i],height[j]) mianji=chang*(j-i) result=max(mianji,result) if height[i]&lt;height[j]: i=i+1 else: j=j-1 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
