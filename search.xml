<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[牛客网]差值对数]]></title>
    <url>%2F2018%2F11%2F08%2F%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%B7%AE%E5%80%BC%E5%AF%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[小Q今天在上厕所时想到了这个问题：有n个数，两两组成二元组，相差最小的有多少对呢？相差最大呢？ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;limits.h&gt;using namespace std;class Solution &#123;public: void fun(vector&lt;int&gt; v) &#123; sort(v.begin(), v.end()); int min = INT_MAX; for (int i = 1; i &lt; v.size(); i++) &#123; if (v[i] - v[i - 1] &lt; min) min = v[i] - v[i - 1]; &#125; int count1 = 0; if (min == 0) &#123; for (int i = 0; i &lt; v.size(); i++) &#123; int j = i + 1; while (j &lt; v.size() &amp;&amp; v[i] == v[j]) &#123; count1++; j++; &#125; &#125; &#125; else &#123; for (int i = 1; i &lt; v.size(); i++) &#123; if (v[i] - v[i - 1] == min) count1++; &#125; &#125; /*cout &lt;&lt; count1 &lt;&lt; endl;*/ int count2 = 0; int max1 = v[v.size() - 1]; int min1 = v[0]; int maxnum = 0, minnum = 0; for (int i = 0; i &lt; v.size(); i++) &#123; if (v[i] == max1) maxnum++; if (v[i] == min1) minnum++; &#125; if (max1 == min1) count2 = v.size()*(v.size() - 1) / 2; else count2 = maxnum * minnum; cout &lt;&lt;count1&lt;&lt;" "&lt;&lt; count2 &lt;&lt; endl; &#125;&#125;;int main()&#123; int n; int temp; while (cin &gt;&gt; n) &#123; vector&lt;int&gt;v; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; v.push_back(temp); &#125; Solution s; s.fun(v); &#125;&#125; 算法首先进行排序首先看差值最小的对数：1.首先计算出最小差值是多少2,根据这个差值来判断2.1 如果差值为0，则是有相同的数，（比如3，3，3则有3对）不能单纯的计算相同数的个数，因为可能存在（3，3，2，2）这种情况，所以必须要遍历字符串，用1int j来寻找每个数相同个数的对数。 2.2 如果差值不为0，则直接计算有多少对差值为最小值的对数。 对于最大值的差值：由于是有序的，可以直接最大的值和最小的值是多少，再根据循环找出最大值和最小值的个数1，如果最小值个数等于最大值的个数，即整个序列相等，对数为n* （n-1）/22，如果不相等，则对数为两个数想乘。 注意本算法的关键有两点：1.首先要排序，可以利用1algorithm头文件中的sort函数直接进行排序 2.判断最小值对数的时候要慢慢来，先算出值，再算对数，要格外注意最小值为0的情况。]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[牛客网]构造回文]]></title>
    <url>%2F2018%2F11%2F06%2F%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%9E%84%E9%80%A0%E5%9B%9E%E6%96%87%2F</url>
    <content type="text"><![CDATA[给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; const int maxn = 1010; class Solution &#123; public: void xuliechangdu(string a,string b, int** Maxnum, int **f,int len1,int len2) &#123;//求应删除的个数 reverse(b.begin(), b.end()); for (int m = 0; m &lt; len1; m++) &#123; Maxnum[m][0] = 0; Maxnum[0][m] = 0; &#125; for (int i = 1; i &lt;= len1; i++) &#123; for (int j = 1; j &lt;= len2; j++) &#123; if (a[i - 1] == b[j - 1]) &#123; Maxnum[i][j] = Maxnum[i - 1][j - 1] + 1; f[i][j] = 1; &#125; else if (Maxnum[i - 1][j] &gt; Maxnum[i][j - 1]) &#123; Maxnum[i][j] = Maxnum[i - 1][j]; f[i][j] = 2; &#125; else &#123; Maxnum[i][j] = Maxnum[i][j - 1]; f[i][j] = 3; &#125; &#125; &#125; int result =len1- Maxnum[len1][len2]; cout &lt;&lt; result &lt;&lt; endl;&#125;void printzixulie(string a, int **f,int n,int m,string &amp;re)//打印出回文串&#123; if (m ==0|| n== 0) return; else if (f[n][m] == 1) &#123; printzixulie(a, f, n - 1, m - 1,re); re.push_back(a[n - 1]); cout &lt;&lt; a[n - 1] &lt;&lt; endl; &#125; else if (f[n][m] == 2) printzixulie(a, f, n - 1, m,re); else printzixulie(a, f, n, m - 1,re); &#125;void PrintOneLCS(string &amp;str1, string &amp;str2, int i, int j, int** &amp;veca) &#123; string lcs_str; while (i &gt; 0 &amp;&amp; j &gt; 0) &#123; if (str1[i - 1] == str2[j - 1]) &#123; lcs_str = str1[i - 1] + lcs_str; --i; --j; &#125; else &#123; //如果左边存在LCS就从左边找否则再从右边找 if (veca[i - 1][j] &gt;= veca[i][j - 1]) --i; else --j; &#125; &#125; cout &lt;&lt; lcs_str &lt;&lt; endl;&#125;void allprint(string &amp;s,string &amp;b,int i,int j,int**&amp;Maxnum,string re)&#123; while (i &gt; 0 &amp;&amp; j &gt; 0) &#123; if (s[i - 1] == b[j - 1]) &#123; re = s[i - 1] + re+" " ; //逆向存放 cout &lt;&lt; re &lt;&lt; endl; --i; --j; &#125; else &#123; if (Maxnum[i - 1][j] &gt; Maxnum[i][j - 1]) //向左走 --i; else if (Maxnum[i - 1][j] &lt; Maxnum[i][j - 1]) //向上走 --j; else &#123; //此时向上向右均为LCS的元素 allprint(s, b, i - 1, j, Maxnum, re); allprint(s, b, i, j - 1, Maxnum, re); return; &#125; &#125; &#125; cout&lt;&lt; re &lt;&lt; endl; /*re.insert(lcs_str);*/&#125; int main() &#123; string s; while (cin &gt;&gt; s) &#123; string b = s; string re; string str2=s; reverse(str2.begin(), str2.end()); int len1 = s.length(); int len2 = b.length(); const int maxn = 1010; int **Maxnum; Maxnum = new int *[maxn]; for (int i = 0; i &lt; maxn; i++) Maxnum[i] = new int[maxn]; /* int Maxnum[maxn][maxn];*/ Solution so; int **f; f = new int*[maxn]; for (int j = 0; j &lt; maxn;j++) f[j]=new int[maxn]; //so.xuliechangdu(s,b,Maxnum,f,len1,len2); //so.printzixulie(s,f,len1,len2,re); //so.PrintOneLCS(s, str2, len1, len2, Maxnum); /*so.allprint(s,str2,len1,len2, Maxnum, re);*/ so.zichuanchangdu(s, b, Maxnum, f, len1, len2); cout &lt;&lt; re &lt;&lt; endl; for (int q = 0; q &lt; maxn; q++) &#123; delete[] Maxnum[q]; &#125; delete[]Maxnum; &#125; &#125; 算法这道题可以看成是求解一个序列和此序列倒序列的最长公共子序列长度问题（LCS），解决此类方法的算法核心是动态规划算法 动态规划算法序列A=(a1,a2,a3……an)，序列B=(b1,b2,b3……bm)，它们的LCS为序列C(c1,c2,c3……ck)123如果an=bm,则ck=an=bm，且ck-1是an-1和bm-1的LCS如果an≠bm，则ck≠an，所以c是an-1和bm的LCS如果an≠bm，则ck≠bm，所以c是bm-1和an的LCS 所以，用p(i,j)来表示序列长度123当n=0，或m=0，p(n,m)=0当n，m≠0，且an=bm，p(n,m)=p(n-1,m-1)+1当n，m≠0，且an≠bm，p(n,m)=max&#123;p(n-1,m),p(n,m-1)&#125; 对应上述的xuliechangdu函数 补充当找到回文串时，需要把这个回文串打印出来，利用动态规划的逆想法，如上述的12void printzixulie(string a, int **f,int n,int m,string &amp;re)&#123;&#125; 通过对求取序列长度函数中的tag标号来判断当前下标的字符是否需要输出，同样利用递归的思想，逐个输出tag为1时相对应下标的字符。 注意本文所述的算法仅适用于本题算法，动态规划问题可以求取两个不同字串的公共字符串长度，需要在本文的算法上稍作修改121.对于输入，需要输入两个不同的字符串2.对于输出，由于公共子串不一定是回文，所以本文的输出是从后往前输出，需要注意反序]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[牛客网]字符移位]]></title>
    <url>%2F2018%2F11%2F05%2Fleetcode-%E5%AD%97%E7%AC%A6%E7%A7%BB%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Solution &#123; public: void zifu2(string s) &#123; int len1 = s.length(); char c; int end = len1; for (int i = 0; i &lt; end;) &#123; c = s[i]; if (c &gt;= 'A'&amp;&amp;c &lt;= 'Z') &#123; for (int j = i; j &lt; len1 - 1; j++) &#123; s[j] = s[j + 1]; &#125; s[len1 - 1] = c; end--; &#125; else i++; &#125; cout &lt;&lt; s &lt;&lt; endl; &#125; &#125;; int main() &#123; string s; while (cin &gt;&gt; s) &#123; Solution so; //so.zifu(); so.zifu2(s); &#125; &#125; 算法对字符串进行循环，循环当中的判断不定（这是本题的关键）如果遇到大写字母，则通过类似冒泡排序的方法一样把这个字母放到最后，此时循环的判断是将end值减少1，即将字符串长度减小1，如果不是大写字母，则此时的判断是将i加1，即判断后面一个字母。这样通过对整个字符串遍历就可以完成任务。]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[牛客网]等差数列]]></title>
    <url>%2F2018%2F10%2F19%2Fleetcode-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[如果一个数列S满足对于所有的合法的i,都有S[i + 1] = S[i] + d, 这里的d也可以是负数和零,我们就称数列S为等差数列。小易现在有一个长度为n的数列x,小易想把x变为一个等差数列。小易允许在数列上做交换任意两个位置的数值的操作,并且交换操作允许交换多次。但是有些数列通过交换还是不能变成等差数列,小易需要判别一个数列是否能通过交换操作变成等差数列 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std; class Solution&#123;public: void Dengcha() &#123; int n; int d; int sum=0; cin&gt;&gt;n; int *a=new int[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) &#123; for(int j=n-2;j&gt;=i;j--) &#123; if (a[j]&gt;a[j+1]) &#123; int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; &#125; d=a[1]-a[0]; for(int i=1;i&lt;n;i++) &#123; if( a[i]+d==a[i+1]) sum++; &#125; if (sum==n-2) cout&lt;&lt;"Possible"&lt;&lt;endl; else cout&lt;&lt;"Impossible"&lt;&lt;endl; &#125; &#125;;int main()&#123; Solution s; s.Dengcha(); &#125; 算法首先对数列中的数进行排序，然后算出前两个数的差，即假定为方差，然后再对每个数检验。 改进其中排序算法可以用sort函数代替1sort(a,a+n); 但是要引入 algorithm的头文件。]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[牛客网]彩色砖块]]></title>
    <url>%2F2018%2F10%2F18%2Fleetcode-%E5%BD%A9%E8%89%B2%E7%A0%96%E5%9D%97%2F</url>
    <content type="text"><![CDATA[小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一行。(如果两种方式所对应的砖块颜色序列是相同的,那么认为这两种方式是一样的。) examples = “ABAB”,那么小易有六种排列的结果:“AABB”,”ABAB”,”ABBA”,”BAAB”,”BABA”,”BBAA”其中只有”AABB”和”BBAA”满足最多只有一对不同颜色的相邻砖块 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Solution&#123;public: void Colour() &#123; string s; cin&gt;&gt;s; string a,b,c; int n=0; int len=s.length(); b=s[0]; for(int i=0;i&lt;len;i++) &#123; a=s[i]; if(a!=b) n=n+1; if (n==2) &#123; if (s[i]==s[i-2]) n=1; else cout&lt;&lt;0&lt;&lt;endl; return ; &#125; b=a; &#125; cout&lt;&lt;n+1&lt;&lt;endl; &#125;&#125;;int main()&#123; Solution ss; ss.Colour();&#125; 改进方法12345678910111213141516#include &lt;iostream&gt; using namespace std; int main() &#123; int a[27] = &#123; 0 &#125;, c, sum = 0; while((c=getchar())&gt;32) if (!a[c - 65]) &#123; sum++; a[c - 65] = 1; &#125; if (sum &gt; 2) cout &lt;&lt; 0; else cout &lt;&lt; sum; &#125; 算法26个大写英文字母A~Z的ASCII码值是65～90 getchar()函数该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF。]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[牛客网]最大乘积]]></title>
    <url>%2F2018%2F10%2F15%2Fleetcode-%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大，要求时间复杂度：O(n)，空间复杂度：O(1) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 class Solution &#123;public:void FindMax()&#123; int n; long result; cin &gt;&gt; n; int *a=new int[n];//用指针a指向NEW动态分配的长度N的内存空间 long long max = 1; long long max_sec = 1; long long max_third = 1; long long min = 1; long long min_sec = 1; if (n&lt;3) return ; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; if (a[i] &gt; max) &#123; max_third = max_sec; max_sec = max; max = a[i]; &#125; else if (a[i] &gt; max_sec) &#123; max_third = max_sec; max_sec = a[i]; &#125; else if (a[i] &gt; max_third) &#123; max_third = a[i]; &#125; else if (a[i] &lt; min) &#123; min_sec = min; min = a[i]; &#125; else if (a[i] &lt; min_sec) min_sec = a[i]; long max1 = max * max_sec*max_third; long max2 = max * min*min_sec; if (max1 &gt;= max2) result = max1; else result = max2; &#125; cout&lt;&lt;result&lt;&lt;endl;&#125; &#125;; int main() &#123; Solution s; s.FindMax(); &#125; 算法：因为要求时间复杂度是N，所以只能有循环。当数组大小小于3的时候，直接返回。 最大乘积只有两种可能：1:三个最大正数相乘2：一个最大正数和两个最小负数所以在循环的时候只要找到这五个数。初始化的时候这五个数可以都初始化为1，在循环中，不断改变它们的值。最后将两种情况比较，输出最大值。 易错点：关于数据的溢出，第一次写的时候把所有的数据类型都定义成int型，但是通过率只有22%，这里没有规定数据大小，所以要注意溢出的问题 疑问n=3的情况怎么判断？如果是一个负数两个正数，输出的是什么？代码直接判断了两个正数相乘输出没有报错通过了？ int ,long , long long类型的范围unsigned int 0～4294967295int -2147483648～2147483647unsigned long 0～4294967295long -2147483648～2147483647long long的最大值：9223372036854775807long long的最值：-9223372036854775808unsigned long long的最大值：18446744073709551615 int64的最大值：9223372036854775807 int64的最小值：-9223372036854775808unsigned __int64的最大值：18446744073709551615 32位下，shrot int long分别是2字节，4字节，4字节，longlong是8字节；64位下，long8字节 int是4字节，longlong 8字节。 int是4字节的，一个字节代表8位二进制，所以int的数据类型是32位。所以可以表示2的32次幂的位数，但是数有正有负，所以是-2的32/2=2的31次到2的31次-1]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]生成括号]]></title>
    <url>%2F2018%2F10%2F12%2Fleetcode-%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.给定n对括号，编写一个函数来生成格式正确的括号的所有组合。 exampleFor example, given n = 3, a solution set is: [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] c++代码 对于这种列出所有结果的题首先还是考虑用递归来解123456789101112131415161718192021222324252627282930#include &lt;vector&gt; #include &lt;iostream&gt; using namespace std; class Solution &#123; public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; paren; backtrack("", paren, n, n); return paren;&#125;void backtrack(string out, vector&lt;string&gt; &amp;paren,int left , int right )&#123; if (left &gt; right) return; if (left==0 &amp;&amp; right==0) paren.push_back(out); else &#123; if (left &gt; 0) backtrack(out + "(", paren, left - 1, right); if (right &gt; 0) backtrack(out + ")", paren, left, right - 1); &#125;&#125; &#125;; int main() &#123; Solution s; s.generateParenthesis(3); &#125; 算法左括号3个，右括号3个，所以我们定义两个变量left和right分别表示剩余左右括号的个数，如果在某次递归时，左括号的个数大于右括号的个数，说明此时生成的字符串中右括号的个数大于左括号的个数，即会出现’)(‘这样的非法串，所以这种情况直接返回，不继续处理。如果left和right都为0，则说明此时生成的字符串已有3个左括号和3个右括号，且字符串合法，则存入结果中后返回。如果以上两种情况都不满足，若此时left大于0，则调用递归函数，注意参数的更新，若right大于0，则调用递归函数，同样要更新参数。 注意分成两个函数来写，因为最终要返回的事一个字符串，但是在迭代过程中，需要范围True或False，所以最好分两个函数，一个函数完成总的框架，范围要的结果，定义迭代的函数。另一个函数就是迭代函数的具体声明。 在声明函数backtrack时，容器paren要用引用，否则，每次退出一个递归，paren里的值将恢复最初的值，无法累计。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]ZigZag]]></title>
    <url>%2F2018%2F10%2F07%2Fleetcode-ZigZag%2F</url>
    <content type="text"><![CDATA[The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows字符串“PAYPALISHIRING”以Z字形图案写在给定数量的行上，如下所示:(您可能希望以固定字体显示此图案以获得更好的易读性）然后逐行阅读：“PAHNAPLSIIGYIR” 编写将采用字符串的代码并在给定多行的情况下进行此转换 c++代码12345678910111213141516171819202122232425#include&lt;iostream&gt; using namespace std; class Solution &#123; public: string convert(string s, int numRows) &#123; int length_s = s.length(); int num_z = (numRows * 2 - 2);//一个完整的z的字符个数 if (numRows == 1) return s; string ren; for (int i = 0; i &lt; numRows; i++) &#123; for (int j = 0; j +i&lt; length_s; j = j + num_z) &#123; ren =ren+ s[i + j]; if (i != 0 &amp;&amp; i != numRows - 1&amp;&amp;num_z-i+j&lt;length_s) ren = ren+s[num_z - i + j]; &#125; &#125; return ren; &#125; &#125;; int main() &#123; Solution s; s.convert("PAYPALISHIRING",3); &#125; 算法一个字符串以另外一种形式返回。找到返回字符串的规律 Z的规律：首先看原字符串的长度，再看每个Z需要多少个字符串； 在每一行中再循环每一个Z，循环每个Z的时候，要注意两个边界第一个：是j循环的条件，每行的首个字母的索引是i+j，因此循环每个j的时候，要保证索引小于总长度第二个：除了首末两行，其余的行每个Z都要返回两个字符串，找到这两个字符串的关系，即第二个字符串索引为Z字符个数-i+j，也要保证这个索引小于总长度 有了这两个边界保证，就不需要去考虑完整Z和不完整Z，完全利用索引去和长度的大小去判断字符串。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]----最长回子串]]></title>
    <url>%2F2018%2F10%2F02%2Fleetcode-%E6%9C%80%E9%95%BF%E5%9B%9E%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.给出一个字符串，找到字符串中最长的回文串，你可以假设字符串的最大长度是1000 Example 1:Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2:Input: “cbbd”Output: “bb” 方法一（差劲）：这是我看到题目的第一想法，相当于遍历了整个字符串，然后当找到和索引i相同的索引j时，再往里面判断是否是对称1234567891011121314151617181920212223242526272829303132class Solution:def longestPalindrome(self, s): """ :type s: str :rtype: str """ i = 0 j = 1 max1 = 1 n = len(s) if n == 0: return s else: while i &lt; n - 1: j = i + 1 while j &lt; n - 1: if s[i] == s[j]: j = j + 1 else: break t=0 while i-t&gt;0 and j&lt;=n-1 : if s[i-1-t] == s[j+t]: t=t+1 else: break if j-i+t*2&gt;max1: max1=j-i ans=s[i:j] i = j return ans 方法二（改进）：对上面的算法进行改进，利用找“核”的思想寻找回文字符串，回文字符串的两个重要“核”：aa和aba类似这样形式的字符串，利用 i=j#这样不用遍历整个字符串 先找到这样的核，再往两边判断是否对称，最后返回索引。 class Solution: def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; i=0 max1=1 n=len(s) ans=s[0] while i&lt;n: j=i+1 while j&lt;n: if s[i]==s[j]: j=j+1 else: break k=0 while i-k&gt;0 and j+k&lt;n: if s[i-k-1]==s[j+k]: k=k+1 else: break length=j-i+2*k if length&gt;max1: max1=length ans=s[i-k:j+k] i=j return ans 比较 第一种方法之所以时间复杂度很大是因为两点： 1：没有利用“核”思想，遍历了整个字符串 2：第一种方法从外往里，而第二种方法是从里往外，更加符合回文字符串的特点，即对称性，节省了很多时间。 我相信还有更好的方法]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]移除链表尾端第n个结点]]></title>
    <url>%2F2018%2F09%2F25%2Fleetcode-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%B0%BE%E7%AB%AF%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Given a linked list, remove the n-th node from the end of list and return its head.给定链接列表，从列表末尾删除第n个节点并返回其头部。 一.c++代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt; using namespace std; //Definition for singly-linked list. struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125; &#125;; class Solution &#123; public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; int length1=1; ListNode* p = head; ListNode* q = head; while (p-&gt;next) &#123; length1++; p = p-&gt;next; &#125; int cha = length1 - n; //if (length1 == 1) // return NULL; if (length1 &lt;= n) head = head-&gt;next; else &#123; for (int i = 0; i &lt; (cha - 1); i++) &#123; q = q-&gt;next; &#125; ListNode *t = q-&gt;next; q-&gt;next = t-&gt;next; delete t; &#125; return head; &#125;&#125;; 测试结果1234567891011121314151617int main() &#123; /*Solution *s;*/ ListNode* l1 = new ListNode(1); ListNode *l11 = l1; l11-&gt;next = new ListNode(2); l11 = l11-&gt;next; l11-&gt;next = new ListNode(3); l11 = l11-&gt;next; l11-&gt;next = new ListNode(4); l11 = l11-&gt;next; l11-&gt;next = new ListNode(5); Solution* s = new Solution; s-&gt;removeNthFromEnd(l1, 1); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode]最长不重复子串]]></title>
    <url>%2F2018%2F09%2F21%2FLeetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Given a string, find the length of the longest substring without repeating characters.给定一个字符串，找到最长子字符串的长度而不重复字符。 一.穷举循环法class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; max1=1 n=0 if s==&quot;&quot;: max1=0 return max1 else: for i in s: n=n+1 t=1 p=n for j in s[n:]: if j in s[n-1:p]: max1 = max(t, max1) break else: t=t+1 max1=max(t,max1) p=p+1 return max1 两次循环外循环：遍历字符串中每一个字符内循环：遍历外循环字符串字符之后的每一个字符串，一旦发现和外循环字符重复，就退出内循环每次内循环更新最长字串的值 二.滑动窗口法class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n=len(s) if s==&quot;&quot;: return 0 if n==1: return 1 else: i=0 j=1 max1=1 while (i&lt;n and j&lt;n): if s[j] in s[i:j]: i=i+1 j=i+1 else: j=j+1 max1=max(max1,(j-i)) return max1 solution中给出了一种滑动窗口概念，在java中运用。在窗口中存储当前数据：[i，j）j一开始等于i。当j索引不在窗口里，窗口末端向后滑，并返回j-i当j索引在窗口里，窗口前端向后滑保证遍历每一个字符 运用到python中和第一种方法的想法是完全一样的，但是算法不同，时间复杂度节省了很多遍历每一个字符和子字符串 可以用滑动窗口的想法来遍历，而不需要用两个for循环 三.还有一种更简便的方法看不懂了。。。。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode]水最大容器]]></title>
    <url>%2F2018%2F09%2F20%2FLeetcode-%E6%B0%B4%E6%9C%80%E5%A4%A7%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.给定n个非负整数a1，a2，…，an，其中每个表示坐标（i，ai）处的点。 绘制n条垂直线，使得线i的两个端点位于（i，ai）和（i，0）。 找到两条线，它们与x轴一起形成一个容器，这样容器就含有最多的水。 一.穷举法需要循坏两个列表长度，时间复杂度大 class Solution: def maxArea(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; length=len(height) mian=[] while length&gt;1: for i in range(length-1): minhei=min(height[0],height[i+1]) mianji=minhei*(i+1) mian.append(mianji) resule=max(mian) height.pop(0) length=length-1 return resule clasee=Solution() t=clasee.maxArea([1,8,6,2,5,4,8,3,7]) print(t) 二.（改进）先计算最远处两根之间的面积，然后较短的一根往里面，这样可以保证虽然距离缩小但是面积不一定缩小，长的一根永远在 class Solution: def maxArea(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; length=(len(height)) i=0 j=length-1 result=0 for n in range((length-1)): chang=min(height[i],height[j]) mianji=chang*(j-i) result=max(mianji,result) if height[i]&lt;height[j]: i=i+1 else: j=j-1 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[leetcode]两数相加]]></title>
    <url>%2F2018%2F09%2F10%2Fleetcode-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself您将获得两个非空链表，表示两个非负整数。 数字以相反的顺序存储，每个节点包含一个数字。 添加两个数字并将其作为链接列表返回。 您可以假设这两个数字不包含任何前导零，除了数字0本身 一.python代码123456789101112131415161718192021222324252627282930313233class Solution: def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ q=l1 p=l2 hum=ListNode(0) w=hum tag=0 while (q or p): if q!=None: x=q.val q=q.next else: x=0 if p!=None: y=p.val p=p.next else: y=0 sum=((x+y+tag)%10) if ((x+y+tag)&gt;9): tag=1 else: tag=0 w.next=ListNode(sum) w=w.next if tag==1: w.next=ListNode(tag) return hum.next 二.C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; int sum; int tag=0; ListNode *num=new ListNode(0); ListNode *w = num; while (l1||l2) &#123; int x; int y; if (l1) &#123; x = l1-&gt;val; l1 = l1-&gt;next; &#125; else x = 0; if (l2) &#123; y = l2-&gt;val; l2 = l2-&gt;next; &#125; else y = 0; sum = (x+y+tag)%10; if ((x + y + tag) &gt;= 10) tag = 1; else tag = 0; /*ListNode* pnew = new ListNode(sum);*/ w-&gt;next = new ListNode(sum); w = w-&gt;next; /* w-&gt;next = pnew; w = pnew;*/ &#125; /*if (tag==1) w-&gt;next = new ListNode(tag);*/ if (tag == 1) &#123; ListNode* pnew = new ListNode(tag); w-&gt;next = pnew; &#125; return num-&gt;next; &#125; &#125;; 链表将一个链表赋值给另一个，他们的next地址指向永远相同。调用一个链表的next，就是将链表后面所有的都打印出来。链表一定要赋值了，才有next的地址，不然链表的next就是空。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]继承]]></title>
    <url>%2F2018%2F05%2F30%2FC-%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承因为本科的时候接触过一段时间java，对继承这个概念印象深刻。 继承限定词 public：父类怎样子类就怎样 class CChild: public CPeaple { }; protected:继承之后，父类的public降级成protected，父类中的protected和private不变父类中的属性不会改变 class CChild: protected CPeaple { }; private：继承之后，父类中都降级成private class CChild: private CPeaple { }; 成员的继承无参构造函数：继承构造的调用顺序：先父类再子类； 含参构造函数如果父类有构造函数，且有参数，子类的构造函数一定要写出来。参数在参数列表传递 class CFather { public: CFather(int a); { } } class CSon:public CFather { public: int a; CSon():CFather(1); { } }; 参数传递只能两级之间。如果CFather继承了别的类，只需在CFather类中加入参数列表，和CSon没关系。当有多个构造函数时，根据参数列表的个数决定调用哪个构造函数 析构函数析构函数调用顺序：先子类再父类 覆盖在子类中有和父类中同名的数据成员，把父类中的覆盖，如果想在子类中用父类的数据成员：类内： cout&lt;&lt;CFather::a&lt;&lt;end; 类外： CSon so； cout&lt;&lt;so.CFather::a&lt;&lt;endl； 子类函数和父类函数同名，并不是重载，调用的时候必须使用CFather::来调用父类的函数。友元函数不能被继承 多态和虚函数多态只针对指针对象，虚函数只针对于函数成员；父类的指针调用子类的函数 CFather *fa = new CSon; fa-&gt;show()//普通函数只能调用父类自己的成员 虚函数virtual： //父类： virtual void show()//虚函数 { cout&lt;&lt;&quot;father&quot;&lt;&lt;endl } //子类： void show() { cout&lt;&lt;&quot;son&quot;&lt;&lt;endl } //main： CFather *fa = new CSon; fa-&gt;show()//用父类的指针调用子类的成员 只有函数名字一样，才能达到这个虚函数调用效果。 重写 针对虚函数； 1.父类是虚函数，子类重写的函数，默认是虚函数； 返回值类型必须相同 2.特殊情况（协变）：当返回的是当前类的引用或者指针，返回值的类型可以是各自类类型。3.虚函数不能是内联函数4.构造函数不能是虚函数 虚表CFather* fa=new CSon; fa-&gt;show; *(int*)fa//获得的是虚表的首地址 把对象的首地址转成int （四字节） ，然后取对象首地址的地址 *(int*)*(int*)fa//获得的是虚表的第一个的地址内容（fun） *((int*)*(int*)fa+1)//获得的是续表第二个的地址内容（show） 虚表的首地址并不知道是什么类型，所以要先转换成int*,然后递增 代码实现： typedef void (*p)(); ((p)(*(int*)*(int*)fa+0)))()//调用 取内容 fun 虚析构多态中，如果释放父类指针，只会调用父类的析构函数，变成虚析构后，子类父类都调用]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]初始化和宏定义]]></title>
    <url>%2F2018%2F05%2F28%2FC-%E5%9F%BA%E7%A1%80-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[初始化，宏定义，常函数和静态成员 初始化和赋值的区别初始化：变量和对象产生的时候赋予一个值，伴随性质赋值：产生之后赋予一个值，随意性质数组的赋值只能单个赋值 int b[12]; b[0]=1; b[1]=2 引用和const一定要初始化 初始化列表class CStu { public: int a; float f; //第一种 CStu():a(12),f(12.23f)//初始化列表 { } //第二种 CStu(int b,float c):a(b),f(c)//初始化的顺序只和声明顺序有关，和书写顺序无关 { } //第三种 CStu():a(12),f(a)//成员间的初始化，f和a要一个类型 { } } 引用和const初始化class CStu { public: int b; int &amp;a; //第一种 CStu(int c):a(b),b(c)//a(c),b(c)这样赋值不行，在构造函数可以输出，但main不行。初始化列表 { } c是局部变量，给b赋值完后，它的值就不存在了 //第二种 CStu(int &amp;c):a(c),b(c) 主函数： int d=12; CStu stu(d) d的作用范围大，一直在 数组和结构体使用初始化列表数组int a[4]; //第一种 CStu():a()//输出都为0，但不是所有编译器都允许 //第二种 CStu() { for(int i=0;i&lt;4;i++) { a[i]=0; } } //第三种 CStu() { memset(a,0,16)//16:占4*4个字节 } 结构体1. struct STU { int i; float f; }; 结构体可以直接赋值 在main函数： STU st={1,12.23f}; STU st1=st//结构体可以这样赋值 2.有疑问在类里调用一个结构体 STU st; CStu(STU sd):st(sd) { } 在main函数里 STU sf={12,12.12f} CStu stu(sf) 宏定义用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本(1)简单的宏定义: #define &lt;宏名&gt; &lt;字符串&gt;例： #define PI 3.1415926 (2) 带参数的宏定义 #define &lt;宏名&gt; (&lt;参数表&gt;) &lt;宏体&gt;例： #define A(x) x 如果是自己编程使用宏替换，则在使用简单宏定义时，当字符串中不只一个符号时，加上括号表现出优先级，如果是带参数的宏定义，则要给宏体中的每个参数加上括号，并在整个宏体上再加一个括号。看到这里，不禁要问，用宏定义这么麻烦，这么容易出错，可不可以摒弃它， 那让我们来看一下在C语言中用宏定义的好处吧。 常函数int a; void show()const { a=12;//报错，常函数不能修改数据成员 int b=12 //内部允许这样 } 常对象： const CStu stu 只能调用常函数，不能调用普通函数 静态成员static int a; static void fun(); 类外初始化，静态成员受private修饰 类外： int CStu::a=13//类外不用加static 输出： cout&lt;&lt;CStu::a&lt;&lt;endl //或者 CStu st; st.a; 静态函数不能调用普通成员静态成员时其他对象公有的，都可以访问 不使用for循环累加class CStu { public: static int b; CStu() { b++; } } int main() { CStu st[5];//5个对象，调用5个构造函数，b++五次，因为静态成员是共享的 cout&lt;&lt;CStu::b&lt;&lt;endl }]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]拷贝构造和重载]]></title>
    <url>%2F2018%2F05%2F27%2FC-%E5%9F%BA%E7%A1%80-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[函数重载和默认参数，拷贝构造，符号重载 默认参数值void fun(int a=12,char c=&apos;c&apos;) { } //全部指定 void fun1(int a ,char c,float f==12.1) { } 部分指定，从右向左连续指定 函数调用，有默认值的参数可以不用传递实参有默认值，传递实参回覆盖默认值 函数重载同一作用域内：函数声明向下函数名相同，参数个数或者类型不同返回值不能作为函数重载的条件当一个函数有两个形参，一个是默认参数，另一个函数重载也是两个形参，会造成调用不明确 拷贝构造c++不允许拷贝构造函数传值参数构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值 public： CStu() { CStu(const CStu&amp; a) } 何时调用1.创建对象并初始化为同类对象 CStu a; 1 CStu a1(a); 2 CStu a2=a; 3 CStu a3=CStu(a) 4 CStu *a3=new CStu(a) 5 a4=a//这个不会调用 2 程序生成对象副本 //1:将以个对象作为实参传递给一个非引用类型的形参， //对象以值传递的方式传入函数参数 void fun(CStu a1)//类外函数 //调用 fun(a) 调用过程： （1）当对象a传入fun函数的形参时，会产生一个临时变量，我们把这个临时变量叫做a1； （2）调用拷贝构造函数，把test的值赋给a1，类似于 Cstu a1(a) （3）等fun函数执行完，析构掉a1对象 //2从一个返回类型为非引用类型的函数返回一个对象 // 对象以值传递的方式从函数返回 CStu fun() { CStu a ; return a;//返回值相当于一个临时变量，调用拷贝构造 } //调用 fun( ) 调用过程： （1）当执行到return时，产生一个临时变量XX （2）调用拷贝构造函数把a的值赋给XX，有点像CStu XX（a） （3）拷贝构造函数执行到最后，析构掉a局部变量 （4）fun函数执行完析构掉XX 拷贝初始化和直接初始化拷贝初始化：把右边的运算对象拷贝到正在创建的对象中直接初始化：使用普通的函数匹配来选择和我们提供参数最匹配的构造函数 情况默认的复制构造函数，逐个复制非静态成员（浅复制）复制的是成员的值。 stcrpy_s(c,4,&apos;abc&apos;)//4:元素个数 默认拷贝构造可以不写，执行的就是复制内容 CStu(const CStu &amp;a) { this-&gt;b=a.b; stcrpy_c(this-&gt;c,4,a.c) //必须写全复制内容 } 同一个类的多个对象，内存排布一样，地址不同 浅拷贝int *a; CStu() { a=new int[2];//指针可以指向数组的首地址 a[0]=1; a[1]=2;//数组别忘了在析构函数释放空间 } //mian： CStu st; CStu st1=st; 程序会报错，原因如下：浅拷贝只是将成员的值进行赋值，两个指针指向一个空间，销毁对象时，析构函数会释放两次，报错。解决方法利用深拷贝 深拷贝对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间 CStu(const CStu&amp; b) { this.a-&gt;new int[2] this.a[0]=b.a[0] this.a[1]=b.a[1] } //mian： CStu st; CStu st1=st; 让st1有自己的空间 可以利用函数 mencpy(this.a,b.c,8)//8表示字节 还有一个方法明天试一下 p = new int; // 为新对象重新动态分配空间 *p = *(r.p); 指针成员要用深拷贝，不能直接赋值 返回值为引用我们的重载运算符返回void、返回对象本身、返回对象引用都是可以的，并不是说一定要返回一个引用，只不过在不同的情况下需要不同的返回值。主要是两个原因：1.允许进行连续赋值 2.防止返回对象的时候调用拷贝构造函数和析构函数导致不必要的开销，降低赋值运算符的效率。 重载运算符返回地址类内重载！！ int a=1; double b=1.2; int nerror = -1; void* operator [](int n) { switch(n) { case 0: return &amp;a; case 1: return &amp;b; } return &amp;nerror; } //main cout&lt;&lt; st[1];//取出了a值得地址 //如果要取出地址相对应的值，利用*取值 cout&lt;&lt;*st[1];//报错，因为返回的void类型没有确定的大小 cout&lt;&lt;*(double*)st[1];//取出相应的值 void* ：通用类型指针，其他类型指针可以往它转换。如果要对他赋值，也要有类型限制 *(double*)st[1]=14； cout&lt;&lt;*(double*)st[1]; 不推荐这样使用，还是推荐使用引用返回值 int&amp; operator [](int n) 自加自减运算符前置++： int operator ++ (CStu&amp; st) { st.age+=1; return st.age; } //main CStu st; cout&lt;&lt;++st; 后置++： int operator ++ (CStu&amp; st，int n)//int n 理解成一个标记，有int n就是后置++ { int a=st.age; st.age+=1; return a; } //main CStu st; cout&lt;&lt;st++; 重载类型转换operator int() const//不改变对象内容 { return a; } 没有返回类型！！但是要写返回值必须是类内定义； 赋值运算符必须定义为成员函数赋值运算符通常应该返回一个指向其左侧运算对象的引用]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]一些函数]]></title>
    <url>%2F2018%2F05%2F26%2FC-%E5%9F%BA%E7%A1%80-%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[析构函数，构造函数，友元和接口函数等 析构函数1~CStu（）//只有一个，不能重载，不能有参数 对象声明周期结束时，自动调用后括号}或者碰到return构造函数是遇到声明语句马上调用12345678 &#123; CStu stu;//执行到这一步，直接调用构造函数 &#125;//执行到这一步，调用析构函数或者return``` 指针对象遇到delete才调用析构函数```cpp Cstu* stu = new CStu; delete stu; 临时对象,作用鱼仅限这一行代码，创建完直接调用析构函数123456789101112 CStu(12)//在内部是创建了一个对象 CStu tu(12)``` **malloc free和 new delete区别**&lt;br&gt;## tihs 指针this指针创建对象时才有（不是成员）&lt;br&gt;当局部变量和外部变量同名```cpp int a; CStu(int a) &#123; this-&gt;a=a &#125; 是成员函数的隐含参数1234567CStu* GetAddr()&#123; return this&#125;//main函数：CStu* p=st.GetAddr()cout&lt;&lt;p&lt;&lt;endl st对象包含对象地址 构造函数class CStu { public: int age; float f;//只有静态常量才能在类中初始化 void fun()//相当于类的初始化函数 { age=12; f=12.12f; } CStu()//构造函数，无返回值 { age=13; f=12.13f; } } int main() { CStu stu; stu.fun(); cout &lt;&lt; stu.a &lt;&lt; &quot; &quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } //需要先调用fun函数，才能调用变量a， 如果有构造函数，可以直接调用 CStu stu; cout &lt;&lt; stu.a &lt;&lt; &quot; &quot; &lt;&lt; endl; 1.作用 2.执行时间：对象创建时调用 CStu *stu = new CStu; stu-&gt;age; 数组new是才能创建对象调用构造函数 构造函数的类型带参数Cstu(int a,float b)//可以指定默认值 { age=a; f=b; } 如果构造函数有参数，在声明时一定要传参 CStu stu(12,12.23f);//不传参数不要括号 可以有多个构造函数（重载） 友元在类里面声明一个友元 Class CStu { public: int a; float b; friend class CTech;//友元类 friend void fun();//友元函数，外部fun函数就是调用类里面的私有和protected变量 } Class CTech { } //友元类去使用私有变量 不受访问修饰符的限制，但是破坏了类的封装性 接口函数Class CStu { private: int age; public: void set()//接口函数 { age=13; } int get()//接口函数 { return age; } } int main() { CStu stu; stu.set(); int a=stu.get(); } age是类里面的私有变量，为了类的封装性。采用接口函数]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]指针和引用]]></title>
    <url>%2F2018%2F05%2F26%2FC-%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[指针，引用，引用变量，引用做参数和返回值，指针和引用的区别 指针new申请指针空间申请单个空间的时候，可以直接初始化但是申请数组时，可以使用memset赋值 delete释放指针在释放数组时，要加方括号 #include &lt;iostream&gt; using namespace std; int main() { ////申请单个空间 //int *p = new int;//new+type 类型匹配上 也可以直接初始化 new int(12) //int *p1=malloc(sizeof(int));c语言！ //char *p = new char; //*p = 12;//写 //cout &lt;&lt; *p &lt;&lt; endl;//读 //delete p;//释放 //申请数组 int *p = new int[5]; memset(p,0,5*4)//赋值数组，5个值，每个int占4个字节，总共20个字节 //int *p1 = malloc(5 * 4); c语言 p[0] = 12; p[1] = 11; cout &lt;&lt; p[0] &lt;&lt; &quot; &quot; &lt;&lt; p[1] &lt;&lt; endl; system(&quot;pause&quot;); delete[]p;//释放数组P 要方括号 return 0; } *作用1 在申明一个变量的时候，*指针变量2 地址操作符 读写3 数字 表示乘法 对内存的操作读 写 取地址&amp; 引用给变量取别名 int a=12; int &amp;c=a;//声明变量a的一个引用c，c时变量a的一个别名 c=13//a的值也改变了 引用的时候一定要初始化可以被多个变量引用与赋值概念不同 指针这个和指针不同 *p=&amp;a; p指向的是a的地址，而不是a本身 但是取别名的话，直接关联本身 其他类型的引用常量的引用const int&amp; a = 12; 不可以修改a的值，只能读 数组的引用1 一维数组： int ar[12]; int (&amp;p)[12]=ar;//引用 类型 2 二维数组 int arr[2][3]; int (&amp;p)[2][3]=arr; 指针的引用int b=12; int *p=&amp;b; int *(&amp;p1)=p; 引用做参数void fun(int&amp; a) { a=13; count&lt;&lt;a&lt;&lt;endl; } void fun1(int a) { a=14; coutn&lt;&lt;a&lt;&lt;endl; } void fun2(int* a) { *a=15; } int main() { int b=12; fun(b); fun1(b); fun2(&amp;b); return 0; } 1.调用fun函数时，a初始化成b,a和b关联同一个空间,在函数fun里给a赋值，调用时，b的值也改变成和a一样 2.调用fun1函数时，把b赋值给了a，给a的空间传递了一个b的值，fun1函数里面a赋值，并不会改变b 3.c语言中，通过调用指针改变外部的值,如图： （引用）交换两个变量的值void exchange(int&amp; a,int&amp; b) { int temp=a; a=b; b=temp; } 不引用直接传入无法改变 指针传入也可以改变两个变量的值 void exchange(int*a,int*b) { int *temp=*a; *a=*b; *b=*temp; } 引用做返回值int&amp; fun() { int a=12; return a; } int main() { int&amp; b=fun(); cout&lt;&lt;b&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 第九行调用了局部变量后，a的内容空间销毁，第十行是非法空间操作！！不要引用局部变量 引用不占存储空间，指针占空间 &amp;作用： 1.变量前加 做引用 2.取地址 3.与运算 引用做参数void fun(int&amp; a) { a=13; count&lt;&lt;a&lt;&lt;endl; } void fun1(int a) { a=14; coutn&lt;&lt;a&lt;&lt;endl; } void fun2(int* a) { *a=15; } int main() { int b=12; fun(b); fun1(b); fun2(&amp;b); return 0; } 1.调用fun函数时，a初始化成b,a和b关联同一个空间,在函数fun里给a赋值，调用时，b的值也改变成和a一样 2.调用fun1函数时，把b赋值给了a，给a的空间传递了一个b的值，fun1函数里面a赋值，并不会改变b 3.c语言中，通过调用指针改变外部的值,如图： （引用）交换两个变量的值void exchange(int&amp; a,int&amp; b) { int temp=a; a=b; b=temp; } 不引用直接传入无法改变 指针传入也可以改变两个变量的值 void exchange(int*a,int*b) { int *temp=*a; *a=*b; *b=*temp; } 引用引用只是别名，不是实体类型（也就是说c++编译器不为引用单独分配内存空间），对一个对象的引用，就是直接对这个对象的操作。 （1）引用必须初始化(引用必须指向所引用的对象) int a = 3;&lt;br&gt; int&amp; ra = a;&lt;br&gt; int &amp;b ;//错误，引用必须初始化 (3)引用不能更换目标 int&amp; ra = a; // int&amp; ra = b;//错误，多次初始化 引用的使用场合？（一）引用型参数（函数形参只是实参的别名，也就是说形参和实参是同一个对象）使用引用型参数有两个好处：（1）因为函数形参和实参是同一个对象，也就不存在对象复制，避免了对象的开销。（2）可以在修改形参的同时对实参的修改。因为不存在拷贝构造所以，可以提高c++程序的执行效率 （2）引用型返回值 从函数中返回引用，一定要保证在函数返回以后，被引用的目标一直有效，也就是不能返回函数体内的局部对象的引用，局部对象离开作用域就会被析构掉，所以不能返回对函数体内的局部对象的引用。 区别和联系指针可以不初始化，可以改变它指向的目标。]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++基础]结构体和类]]></title>
    <url>%2F2018%2F05%2F25%2FC-%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[一些基础知识点，结构体和类理论 基础知识点主函数：应用程序入口一个项目只能有一个主函数 主函数形式1:int main()c++标准形式2:int main(void) c标准形式3:int main(int argc,char* argv[ ]) 命令行参数4:main() c5:void main() (不提倡) 输出 输入cout可以连续输出，自动识别类型&lt;&lt;’a’&lt;&lt;21&lt;&lt;”dddd”“” 字符串‘’字符小数自动识别成double，所以定义浮点数时，要在最后加ffloat b=12.122f endl换行，并且清空刷新缓冲区\n换行符依旧可以用 c结构体结构体中不能直接有函数成员，但可以通过一定的语法间接调用函数，比如函数指针声明结构体变量必须有struct关键字123456789101112131415161718#include &lt;stdio.h&gt;typedef struct Node&#123; int m; void(*p)();//函数指针&#125;;void fun()&#123; printf("hello");&#125;int main(void)&#123; struct Node a = &#123; 1,fun &#125;; a.p();//调用函数 return 0;&#125;; 在C中定义一个结构体类型要用typedef: 1234typedef struct Student &#123; int a; &#125;Stu; 于是在声明变量的时候就可：Stu stu1;(如果没有typedef就必须用struct Student stu1;来声明)这里的Stu实际上就是struct Student的别名。Stu==struct Student1234typedef struct&#123;int a;&#125;Stu; 另外这里也可以不写Student（于是也不能struct Student stu1;了，必须是Stu stu1;） c++ 结构体在c++中如果用typedef的话，又会造成区别：1234struct Student &#123; int a; &#125;stu1;//stu1是一个变量 1234typedef struct Student2 &#123; int a; &#125;stu2;//stu2是一个结构体类型=struct Studen 声明变量不用struct可以放函数成员12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;struct Node&#123; int m; void fun() &#123; printf("hello"); &#125;&#125;;int main() &#123; Node a; a.fun(); system("pause"); return 0;&#125;;]]></content>
      <categories>
        <category>c++基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lujing--Blog]]></title>
    <url>%2F2018%2F01%2F24%2FLujing-Blog%2F</url>
    <content type="text"><![CDATA[之前弄过一次博客，后来被我荒废了，主题配置文件还出了错，这次就重新来过。 作为一名研一的工科女生]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
